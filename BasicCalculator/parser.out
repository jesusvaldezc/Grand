Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    LBRACK
    RBRACK
    UMINUS

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID var_assign subrutinas a END PROGRAM ID
Rule 2     type_definition -> INT_TYPE
Rule 3     type_definition -> FLOAT_TYPE
Rule 4     var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
Rule 5     var_assign -> empty
Rule 6     var_dimensiones -> LARR constante_entero RARR
Rule 7     var_dimensiones -> LARR constante_entero COMMA constante_entero RARR
Rule 8     var_dimensiones -> empty
Rule 9     create_var_table -> empty
Rule 10    var_local -> ID COMMA var_local
Rule 11    var_local -> ID
Rule 12    subrutinas -> f_local
Rule 13    subrutinas -> empty
Rule 14    f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local
Rule 15    f_local -> SUBROUTINE ID d END SUBROUTINE ID
Rule 16    a -> BEGIN d END
Rule 17    d -> b
Rule 18    d -> b d
Rule 19    b -> variable_matrix_assign
Rule 20    b -> printing_variables
Rule 21    b -> if_expression
Rule 22    b -> do_loop
Rule 23    b -> do_contador
Rule 24    b -> do_while_loop
Rule 25    b -> call_subroutine
Rule 26    b -> reading_variables
Rule 27    b -> EXIT
Rule 28    do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO
Rule 29    do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
Rule 30    do_loop -> DO LOOP d END_DO
Rule 31    do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
Rule 32    reading_variables -> READ ID
Rule 33    call_subroutine -> CALL ID
Rule 34    if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
Rule 35    if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
Rule 36    if_expression_local -> d
Rule 37    if_expression_local -> empty
Rule 38    if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2
Rule 39    if_expression_local2 -> empty
Rule 40    printing_variables -> PRINT LPAREN expression_arith RPAREN
Rule 41    printing_variables -> PRINT LPAREN STRING RPAREN
Rule 42    variable_matrix_assign -> ID ASSIGN expression_arith
Rule 43    variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith
Rule 44    variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
Rule 45    expression_arith -> expression_arith PLUS c
Rule 46    expression_arith -> expression_arith MINUS c
Rule 47    expression_arith -> c
Rule 48    c -> c MULTIPLY te
Rule 49    c -> c DIVIDE te
Rule 50    c -> te
Rule 51    te -> ID
Rule 52    te -> constante_entero
Rule 53    te -> constante_flotante
Rule 54    te -> ID LPAREN expression_arith RPAREN
Rule 55    te -> ID LPAREN expression_arith COMMA expression_arith RPAREN
Rule 56    te -> LPAREN expression_arith RPAREN
Rule 57    expression_logic -> expression_logic OR g
Rule 58    expression_logic -> g
Rule 59    g -> g AND ge
Rule 60    g -> ge
Rule 61    ge -> ID GT ID
Rule 62    ge -> ID LT ID
Rule 63    ge -> ID GE ID
Rule 64    ge -> ID LE ID
Rule 65    ge -> ID NE ID
Rule 66    ge -> ID EQUAL ID
Rule 67    ge -> LPAREN expression_logic RPAREN
Rule 68    crearCuadruploGoToF -> empty
Rule 69    crearCuadruploGoTo -> empty
Rule 70    acabarIF -> empty
Rule 71    constante_entero -> INT
Rule 72    constante_flotante -> FLOAT
Rule 73    paso1DO -> empty
Rule 74    paso2DO -> empty
Rule 75    empty -> <empty>

Terminals, with rules where they appear

AND                  : 59
ASSIGN               : 42 43 44
BEGIN                : 16
CALL                 : 33
COLONS               : 4 4
COMMA                : 7 10 28 28 29 29 44 55
COMMENT              : 
DIVIDE               : 49
DO                   : 28 29 30 31
ELSE                 : 34
ELSIF                : 38
END                  : 1 14 15 16
END_DO               : 28 29 30 31
END_IF               : 34 35
EQUAL                : 66
EXIT                 : 27
FLOAT                : 72
FLOAT_TYPE           : 3
GE                   : 63
GT                   : 61
ID                   : 1 1 10 11 14 14 15 15 28 28 32 33 42 43 44 51 54 55 61 61 62 62 63 63 64 64 65 65 66 66
IF                   : 34 35
INT                  : 71
INT_TYPE             : 2
LARR                 : 6 7
LBRACK               : 
LE                   : 64
LOOP                 : 30 31
LPAREN               : 40 41 43 44 54 55 56 67
LT                   : 62
MINUS                : 46
MULTIPLY             : 48
NE                   : 65
OR                   : 57
PLUS                 : 45
PRINT                : 40 41
PROGRAM              : 1 1
RARR                 : 6 7
RBRACK               : 
READ                 : 32
RPAREN               : 40 41 43 44 54 55 56 67
STRING               : 41
SUBROUTINE           : 14 14 15 15
THEN                 : 34 35 38
UMINUS               : 
WHILE                : 31
error                : 

Nonterminals, with rules where they appear

a                    : 1
acabarIF             : 34 35
b                    : 17 18
c                    : 45 46 47 48 49
call_subroutine      : 25
constante_entero     : 6 7 7 29 29 52
constante_flotante   : 53
crearCuadruploGoTo   : 34
crearCuadruploGoToF  : 34 35
create_var_table     : 4
d                    : 14 15 16 18 28 29 30 31 36
do_contador          : 23
do_loop              : 22
do_while_loop        : 24
empty                : 5 8 9 13 37 39 68 69 70 73 74
expression_arith     : 40 42 43 43 44 44 44 45 46 54 55 55 56
expression_logic     : 31 34 35 38 57 67
f_local              : 12 14
g                    : 57 58 59
ge                   : 59 60
if_expression        : 21
if_expression_local  : 34 34 35 38
if_expression_local2 : 34 38
paso1DO              : 31
paso2DO              : 31
printing_variables   : 20
program              : 0
reading_variables    : 26
subrutinas           : 1
te                   : 48 49 50
type_definition      : 4
var_assign           : 1 4
var_dimensiones      : 4
var_local            : 4 10
variable_matrix_assign : 19 28 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID var_assign subrutinas a END PROGRAM ID

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID var_assign subrutinas a END PROGRAM ID

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . var_assign subrutinas a END PROGRAM ID
    (4) var_assign -> . type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
    (5) var_assign -> . empty
    (2) type_definition -> . INT_TYPE
    (3) type_definition -> . FLOAT_TYPE
    (75) empty -> .

    INT_TYPE        shift and go to state 7
    FLOAT_TYPE      shift and go to state 8
    SUBROUTINE      reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)

    var_assign                     shift and go to state 4
    type_definition                shift and go to state 5
    empty                          shift and go to state 6

state 4

    (1) program -> PROGRAM ID var_assign . subrutinas a END PROGRAM ID
    (12) subrutinas -> . f_local
    (13) subrutinas -> . empty
    (14) f_local -> . SUBROUTINE ID d END SUBROUTINE ID f_local
    (15) f_local -> . SUBROUTINE ID d END SUBROUTINE ID
    (75) empty -> .

    SUBROUTINE      shift and go to state 12
    BEGIN           reduce using rule 75 (empty -> .)

    subrutinas                     shift and go to state 9
    f_local                        shift and go to state 10
    empty                          shift and go to state 11

state 5

    (4) var_assign -> type_definition . COLONS COLONS var_local var_dimensiones create_var_table var_assign

    COLONS          shift and go to state 13


state 6

    (5) var_assign -> empty .

    SUBROUTINE      reduce using rule 5 (var_assign -> empty .)
    BEGIN           reduce using rule 5 (var_assign -> empty .)


state 7

    (2) type_definition -> INT_TYPE .

    COLONS          reduce using rule 2 (type_definition -> INT_TYPE .)


state 8

    (3) type_definition -> FLOAT_TYPE .

    COLONS          reduce using rule 3 (type_definition -> FLOAT_TYPE .)


state 9

    (1) program -> PROGRAM ID var_assign subrutinas . a END PROGRAM ID
    (16) a -> . BEGIN d END

    BEGIN           shift and go to state 15

    a                              shift and go to state 14

state 10

    (12) subrutinas -> f_local .

    BEGIN           reduce using rule 12 (subrutinas -> f_local .)


state 11

    (13) subrutinas -> empty .

    BEGIN           reduce using rule 13 (subrutinas -> empty .)


state 12

    (14) f_local -> SUBROUTINE . ID d END SUBROUTINE ID f_local
    (15) f_local -> SUBROUTINE . ID d END SUBROUTINE ID

    ID              shift and go to state 16


state 13

    (4) var_assign -> type_definition COLONS . COLONS var_local var_dimensiones create_var_table var_assign

    COLONS          shift and go to state 17


state 14

    (1) program -> PROGRAM ID var_assign subrutinas a . END PROGRAM ID

    END             shift and go to state 18


state 15

    (16) a -> BEGIN . d END
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    d                              shift and go to state 19
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 16

    (14) f_local -> SUBROUTINE ID . d END SUBROUTINE ID f_local
    (15) f_local -> SUBROUTINE ID . d END SUBROUTINE ID
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    d                              shift and go to state 36
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 17

    (4) var_assign -> type_definition COLONS COLONS . var_local var_dimensiones create_var_table var_assign
    (10) var_local -> . ID COMMA var_local
    (11) var_local -> . ID

    ID              shift and go to state 38

    var_local                      shift and go to state 37

state 18

    (1) program -> PROGRAM ID var_assign subrutinas a END . PROGRAM ID

    PROGRAM         shift and go to state 39


state 19

    (16) a -> BEGIN d . END

    END             shift and go to state 40


state 20

    (17) d -> b .
    (18) d -> b . d
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    END             reduce using rule 17 (d -> b .)
    END_DO          reduce using rule 17 (d -> b .)
    WHILE           reduce using rule 17 (d -> b .)
    ELSIF           reduce using rule 17 (d -> b .)
    ELSE            reduce using rule 17 (d -> b .)
    END_IF          reduce using rule 17 (d -> b .)
    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    b                              shift and go to state 20
    d                              shift and go to state 41
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 21

    (19) b -> variable_matrix_assign .

    EXIT            reduce using rule 19 (b -> variable_matrix_assign .)
    ID              reduce using rule 19 (b -> variable_matrix_assign .)
    PRINT           reduce using rule 19 (b -> variable_matrix_assign .)
    IF              reduce using rule 19 (b -> variable_matrix_assign .)
    DO              reduce using rule 19 (b -> variable_matrix_assign .)
    CALL            reduce using rule 19 (b -> variable_matrix_assign .)
    READ            reduce using rule 19 (b -> variable_matrix_assign .)
    END             reduce using rule 19 (b -> variable_matrix_assign .)
    END_DO          reduce using rule 19 (b -> variable_matrix_assign .)
    WHILE           reduce using rule 19 (b -> variable_matrix_assign .)
    ELSIF           reduce using rule 19 (b -> variable_matrix_assign .)
    ELSE            reduce using rule 19 (b -> variable_matrix_assign .)
    END_IF          reduce using rule 19 (b -> variable_matrix_assign .)


state 22

    (20) b -> printing_variables .

    EXIT            reduce using rule 20 (b -> printing_variables .)
    ID              reduce using rule 20 (b -> printing_variables .)
    PRINT           reduce using rule 20 (b -> printing_variables .)
    IF              reduce using rule 20 (b -> printing_variables .)
    DO              reduce using rule 20 (b -> printing_variables .)
    CALL            reduce using rule 20 (b -> printing_variables .)
    READ            reduce using rule 20 (b -> printing_variables .)
    END             reduce using rule 20 (b -> printing_variables .)
    END_DO          reduce using rule 20 (b -> printing_variables .)
    WHILE           reduce using rule 20 (b -> printing_variables .)
    ELSIF           reduce using rule 20 (b -> printing_variables .)
    ELSE            reduce using rule 20 (b -> printing_variables .)
    END_IF          reduce using rule 20 (b -> printing_variables .)


state 23

    (21) b -> if_expression .

    EXIT            reduce using rule 21 (b -> if_expression .)
    ID              reduce using rule 21 (b -> if_expression .)
    PRINT           reduce using rule 21 (b -> if_expression .)
    IF              reduce using rule 21 (b -> if_expression .)
    DO              reduce using rule 21 (b -> if_expression .)
    CALL            reduce using rule 21 (b -> if_expression .)
    READ            reduce using rule 21 (b -> if_expression .)
    END             reduce using rule 21 (b -> if_expression .)
    END_DO          reduce using rule 21 (b -> if_expression .)
    WHILE           reduce using rule 21 (b -> if_expression .)
    ELSIF           reduce using rule 21 (b -> if_expression .)
    ELSE            reduce using rule 21 (b -> if_expression .)
    END_IF          reduce using rule 21 (b -> if_expression .)


state 24

    (22) b -> do_loop .

    EXIT            reduce using rule 22 (b -> do_loop .)
    ID              reduce using rule 22 (b -> do_loop .)
    PRINT           reduce using rule 22 (b -> do_loop .)
    IF              reduce using rule 22 (b -> do_loop .)
    DO              reduce using rule 22 (b -> do_loop .)
    CALL            reduce using rule 22 (b -> do_loop .)
    READ            reduce using rule 22 (b -> do_loop .)
    END             reduce using rule 22 (b -> do_loop .)
    END_DO          reduce using rule 22 (b -> do_loop .)
    WHILE           reduce using rule 22 (b -> do_loop .)
    ELSIF           reduce using rule 22 (b -> do_loop .)
    ELSE            reduce using rule 22 (b -> do_loop .)
    END_IF          reduce using rule 22 (b -> do_loop .)


state 25

    (23) b -> do_contador .

    EXIT            reduce using rule 23 (b -> do_contador .)
    ID              reduce using rule 23 (b -> do_contador .)
    PRINT           reduce using rule 23 (b -> do_contador .)
    IF              reduce using rule 23 (b -> do_contador .)
    DO              reduce using rule 23 (b -> do_contador .)
    CALL            reduce using rule 23 (b -> do_contador .)
    READ            reduce using rule 23 (b -> do_contador .)
    END             reduce using rule 23 (b -> do_contador .)
    END_DO          reduce using rule 23 (b -> do_contador .)
    WHILE           reduce using rule 23 (b -> do_contador .)
    ELSIF           reduce using rule 23 (b -> do_contador .)
    ELSE            reduce using rule 23 (b -> do_contador .)
    END_IF          reduce using rule 23 (b -> do_contador .)


state 26

    (24) b -> do_while_loop .

    EXIT            reduce using rule 24 (b -> do_while_loop .)
    ID              reduce using rule 24 (b -> do_while_loop .)
    PRINT           reduce using rule 24 (b -> do_while_loop .)
    IF              reduce using rule 24 (b -> do_while_loop .)
    DO              reduce using rule 24 (b -> do_while_loop .)
    CALL            reduce using rule 24 (b -> do_while_loop .)
    READ            reduce using rule 24 (b -> do_while_loop .)
    END             reduce using rule 24 (b -> do_while_loop .)
    END_DO          reduce using rule 24 (b -> do_while_loop .)
    WHILE           reduce using rule 24 (b -> do_while_loop .)
    ELSIF           reduce using rule 24 (b -> do_while_loop .)
    ELSE            reduce using rule 24 (b -> do_while_loop .)
    END_IF          reduce using rule 24 (b -> do_while_loop .)


state 27

    (25) b -> call_subroutine .

    EXIT            reduce using rule 25 (b -> call_subroutine .)
    ID              reduce using rule 25 (b -> call_subroutine .)
    PRINT           reduce using rule 25 (b -> call_subroutine .)
    IF              reduce using rule 25 (b -> call_subroutine .)
    DO              reduce using rule 25 (b -> call_subroutine .)
    CALL            reduce using rule 25 (b -> call_subroutine .)
    READ            reduce using rule 25 (b -> call_subroutine .)
    END             reduce using rule 25 (b -> call_subroutine .)
    END_DO          reduce using rule 25 (b -> call_subroutine .)
    WHILE           reduce using rule 25 (b -> call_subroutine .)
    ELSIF           reduce using rule 25 (b -> call_subroutine .)
    ELSE            reduce using rule 25 (b -> call_subroutine .)
    END_IF          reduce using rule 25 (b -> call_subroutine .)


state 28

    (26) b -> reading_variables .

    EXIT            reduce using rule 26 (b -> reading_variables .)
    ID              reduce using rule 26 (b -> reading_variables .)
    PRINT           reduce using rule 26 (b -> reading_variables .)
    IF              reduce using rule 26 (b -> reading_variables .)
    DO              reduce using rule 26 (b -> reading_variables .)
    CALL            reduce using rule 26 (b -> reading_variables .)
    READ            reduce using rule 26 (b -> reading_variables .)
    END             reduce using rule 26 (b -> reading_variables .)
    END_DO          reduce using rule 26 (b -> reading_variables .)
    WHILE           reduce using rule 26 (b -> reading_variables .)
    ELSIF           reduce using rule 26 (b -> reading_variables .)
    ELSE            reduce using rule 26 (b -> reading_variables .)
    END_IF          reduce using rule 26 (b -> reading_variables .)


state 29

    (27) b -> EXIT .

    EXIT            reduce using rule 27 (b -> EXIT .)
    ID              reduce using rule 27 (b -> EXIT .)
    PRINT           reduce using rule 27 (b -> EXIT .)
    IF              reduce using rule 27 (b -> EXIT .)
    DO              reduce using rule 27 (b -> EXIT .)
    CALL            reduce using rule 27 (b -> EXIT .)
    READ            reduce using rule 27 (b -> EXIT .)
    END             reduce using rule 27 (b -> EXIT .)
    END_DO          reduce using rule 27 (b -> EXIT .)
    WHILE           reduce using rule 27 (b -> EXIT .)
    ELSIF           reduce using rule 27 (b -> EXIT .)
    ELSE            reduce using rule 27 (b -> EXIT .)
    END_IF          reduce using rule 27 (b -> EXIT .)


state 30

    (42) variable_matrix_assign -> ID . ASSIGN expression_arith
    (43) variable_matrix_assign -> ID . LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> ID . LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith

    ASSIGN          shift and go to state 42
    LPAREN          shift and go to state 43


state 31

    (40) printing_variables -> PRINT . LPAREN expression_arith RPAREN
    (41) printing_variables -> PRINT . LPAREN STRING RPAREN

    LPAREN          shift and go to state 44


state 32

    (34) if_expression -> IF . expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> IF . expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (57) expression_logic -> . expression_logic OR g
    (58) expression_logic -> . g
    (59) g -> . g AND ge
    (60) g -> . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    expression_logic               shift and go to state 45
    g                              shift and go to state 46
    ge                             shift and go to state 47

state 33

    (30) do_loop -> DO . LOOP d END_DO
    (28) do_contador -> DO . ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> DO . constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> DO . paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (71) constante_entero -> . INT
    (73) paso1DO -> . empty
    (75) empty -> .

  ! shift/reduce conflict for LOOP resolved as shift
    LOOP            shift and go to state 50
    ID              shift and go to state 51
    INT             shift and go to state 54

  ! LOOP            [ reduce using rule 75 (empty -> .) ]

    constante_entero               shift and go to state 52
    paso1DO                        shift and go to state 53
    empty                          shift and go to state 55

state 34

    (33) call_subroutine -> CALL . ID

    ID              shift and go to state 56


state 35

    (32) reading_variables -> READ . ID

    ID              shift and go to state 57


state 36

    (14) f_local -> SUBROUTINE ID d . END SUBROUTINE ID f_local
    (15) f_local -> SUBROUTINE ID d . END SUBROUTINE ID

    END             shift and go to state 58


state 37

    (4) var_assign -> type_definition COLONS COLONS var_local . var_dimensiones create_var_table var_assign
    (6) var_dimensiones -> . LARR constante_entero RARR
    (7) var_dimensiones -> . LARR constante_entero COMMA constante_entero RARR
    (8) var_dimensiones -> . empty
    (75) empty -> .

    LARR            shift and go to state 60
    INT_TYPE        reduce using rule 75 (empty -> .)
    FLOAT_TYPE      reduce using rule 75 (empty -> .)
    SUBROUTINE      reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)

    var_dimensiones                shift and go to state 59
    empty                          shift and go to state 61

state 38

    (10) var_local -> ID . COMMA var_local
    (11) var_local -> ID .

    COMMA           shift and go to state 62
    LARR            reduce using rule 11 (var_local -> ID .)
    INT_TYPE        reduce using rule 11 (var_local -> ID .)
    FLOAT_TYPE      reduce using rule 11 (var_local -> ID .)
    SUBROUTINE      reduce using rule 11 (var_local -> ID .)
    BEGIN           reduce using rule 11 (var_local -> ID .)


state 39

    (1) program -> PROGRAM ID var_assign subrutinas a END PROGRAM . ID

    ID              shift and go to state 63


state 40

    (16) a -> BEGIN d END .

    END             reduce using rule 16 (a -> BEGIN d END .)


state 41

    (18) d -> b d .

    END             reduce using rule 18 (d -> b d .)
    END_DO          reduce using rule 18 (d -> b d .)
    WHILE           reduce using rule 18 (d -> b d .)
    ELSIF           reduce using rule 18 (d -> b d .)
    ELSE            reduce using rule 18 (d -> b d .)
    END_IF          reduce using rule 18 (d -> b d .)


state 42

    (42) variable_matrix_assign -> ID ASSIGN . expression_arith
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 65
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 43

    (43) variable_matrix_assign -> ID LPAREN . expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> ID LPAREN . expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 72
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 44

    (40) printing_variables -> PRINT LPAREN . expression_arith RPAREN
    (41) printing_variables -> PRINT LPAREN . STRING RPAREN
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    STRING          shift and go to state 74
    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 73
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 45

    (34) if_expression -> IF expression_logic . crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> IF expression_logic . crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (57) expression_logic -> expression_logic . OR g
    (68) crearCuadruploGoToF -> . empty
    (75) empty -> .

    OR              shift and go to state 76
    THEN            reduce using rule 75 (empty -> .)

    crearCuadruploGoToF            shift and go to state 75
    empty                          shift and go to state 77

state 46

    (58) expression_logic -> g .
    (59) g -> g . AND ge

    OR              reduce using rule 58 (expression_logic -> g .)
    THEN            reduce using rule 58 (expression_logic -> g .)
    RPAREN          reduce using rule 58 (expression_logic -> g .)
    END_DO          reduce using rule 58 (expression_logic -> g .)
    AND             shift and go to state 78


state 47

    (60) g -> ge .

    AND             reduce using rule 60 (g -> ge .)
    OR              reduce using rule 60 (g -> ge .)
    THEN            reduce using rule 60 (g -> ge .)
    RPAREN          reduce using rule 60 (g -> ge .)
    END_DO          reduce using rule 60 (g -> ge .)


state 48

    (61) ge -> ID . GT ID
    (62) ge -> ID . LT ID
    (63) ge -> ID . GE ID
    (64) ge -> ID . LE ID
    (65) ge -> ID . NE ID
    (66) ge -> ID . EQUAL ID

    GT              shift and go to state 79
    LT              shift and go to state 80
    GE              shift and go to state 81
    LE              shift and go to state 82
    NE              shift and go to state 83
    EQUAL           shift and go to state 84


state 49

    (67) ge -> LPAREN . expression_logic RPAREN
    (57) expression_logic -> . expression_logic OR g
    (58) expression_logic -> . g
    (59) g -> . g AND ge
    (60) g -> . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    expression_logic               shift and go to state 85
    g                              shift and go to state 46
    ge                             shift and go to state 47

state 50

    (30) do_loop -> DO LOOP . d END_DO
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    d                              shift and go to state 86
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 51

    (28) do_contador -> DO ID . COMMA ID COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 87


state 52

    (29) do_contador -> DO constante_entero . COMMA constante_entero COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 88


state 53

    (31) do_while_loop -> DO paso1DO . LOOP d WHILE expression_logic paso2DO END_DO

    LOOP            shift and go to state 89


state 54

    (71) constante_entero -> INT .

    COMMA           reduce using rule 71 (constante_entero -> INT .)
    MULTIPLY        reduce using rule 71 (constante_entero -> INT .)
    DIVIDE          reduce using rule 71 (constante_entero -> INT .)
    PLUS            reduce using rule 71 (constante_entero -> INT .)
    MINUS           reduce using rule 71 (constante_entero -> INT .)
    EXIT            reduce using rule 71 (constante_entero -> INT .)
    ID              reduce using rule 71 (constante_entero -> INT .)
    PRINT           reduce using rule 71 (constante_entero -> INT .)
    IF              reduce using rule 71 (constante_entero -> INT .)
    DO              reduce using rule 71 (constante_entero -> INT .)
    CALL            reduce using rule 71 (constante_entero -> INT .)
    READ            reduce using rule 71 (constante_entero -> INT .)
    END             reduce using rule 71 (constante_entero -> INT .)
    END_DO          reduce using rule 71 (constante_entero -> INT .)
    WHILE           reduce using rule 71 (constante_entero -> INT .)
    ELSIF           reduce using rule 71 (constante_entero -> INT .)
    ELSE            reduce using rule 71 (constante_entero -> INT .)
    END_IF          reduce using rule 71 (constante_entero -> INT .)
    RPAREN          reduce using rule 71 (constante_entero -> INT .)
    RARR            reduce using rule 71 (constante_entero -> INT .)


state 55

    (73) paso1DO -> empty .

    LOOP            reduce using rule 73 (paso1DO -> empty .)


state 56

    (33) call_subroutine -> CALL ID .

    EXIT            reduce using rule 33 (call_subroutine -> CALL ID .)
    ID              reduce using rule 33 (call_subroutine -> CALL ID .)
    PRINT           reduce using rule 33 (call_subroutine -> CALL ID .)
    IF              reduce using rule 33 (call_subroutine -> CALL ID .)
    DO              reduce using rule 33 (call_subroutine -> CALL ID .)
    CALL            reduce using rule 33 (call_subroutine -> CALL ID .)
    READ            reduce using rule 33 (call_subroutine -> CALL ID .)
    END             reduce using rule 33 (call_subroutine -> CALL ID .)
    END_DO          reduce using rule 33 (call_subroutine -> CALL ID .)
    WHILE           reduce using rule 33 (call_subroutine -> CALL ID .)
    ELSIF           reduce using rule 33 (call_subroutine -> CALL ID .)
    ELSE            reduce using rule 33 (call_subroutine -> CALL ID .)
    END_IF          reduce using rule 33 (call_subroutine -> CALL ID .)


state 57

    (32) reading_variables -> READ ID .

    EXIT            reduce using rule 32 (reading_variables -> READ ID .)
    ID              reduce using rule 32 (reading_variables -> READ ID .)
    PRINT           reduce using rule 32 (reading_variables -> READ ID .)
    IF              reduce using rule 32 (reading_variables -> READ ID .)
    DO              reduce using rule 32 (reading_variables -> READ ID .)
    CALL            reduce using rule 32 (reading_variables -> READ ID .)
    READ            reduce using rule 32 (reading_variables -> READ ID .)
    END             reduce using rule 32 (reading_variables -> READ ID .)
    END_DO          reduce using rule 32 (reading_variables -> READ ID .)
    WHILE           reduce using rule 32 (reading_variables -> READ ID .)
    ELSIF           reduce using rule 32 (reading_variables -> READ ID .)
    ELSE            reduce using rule 32 (reading_variables -> READ ID .)
    END_IF          reduce using rule 32 (reading_variables -> READ ID .)


state 58

    (14) f_local -> SUBROUTINE ID d END . SUBROUTINE ID f_local
    (15) f_local -> SUBROUTINE ID d END . SUBROUTINE ID

    SUBROUTINE      shift and go to state 90


state 59

    (4) var_assign -> type_definition COLONS COLONS var_local var_dimensiones . create_var_table var_assign
    (9) create_var_table -> . empty
    (75) empty -> .

    INT_TYPE        reduce using rule 75 (empty -> .)
    FLOAT_TYPE      reduce using rule 75 (empty -> .)
    SUBROUTINE      reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)

    create_var_table               shift and go to state 91
    empty                          shift and go to state 92

state 60

    (6) var_dimensiones -> LARR . constante_entero RARR
    (7) var_dimensiones -> LARR . constante_entero COMMA constante_entero RARR
    (71) constante_entero -> . INT

    INT             shift and go to state 54

    constante_entero               shift and go to state 93

state 61

    (8) var_dimensiones -> empty .

    INT_TYPE        reduce using rule 8 (var_dimensiones -> empty .)
    FLOAT_TYPE      reduce using rule 8 (var_dimensiones -> empty .)
    SUBROUTINE      reduce using rule 8 (var_dimensiones -> empty .)
    BEGIN           reduce using rule 8 (var_dimensiones -> empty .)


state 62

    (10) var_local -> ID COMMA . var_local
    (10) var_local -> . ID COMMA var_local
    (11) var_local -> . ID

    ID              shift and go to state 38

    var_local                      shift and go to state 94

state 63

    (1) program -> PROGRAM ID var_assign subrutinas a END PROGRAM ID .

    $end            reduce using rule 1 (program -> PROGRAM ID var_assign subrutinas a END PROGRAM ID .)


state 64

    (51) te -> ID .
    (54) te -> ID . LPAREN expression_arith RPAREN
    (55) te -> ID . LPAREN expression_arith COMMA expression_arith RPAREN

    MULTIPLY        reduce using rule 51 (te -> ID .)
    DIVIDE          reduce using rule 51 (te -> ID .)
    PLUS            reduce using rule 51 (te -> ID .)
    MINUS           reduce using rule 51 (te -> ID .)
    EXIT            reduce using rule 51 (te -> ID .)
    ID              reduce using rule 51 (te -> ID .)
    PRINT           reduce using rule 51 (te -> ID .)
    IF              reduce using rule 51 (te -> ID .)
    DO              reduce using rule 51 (te -> ID .)
    CALL            reduce using rule 51 (te -> ID .)
    READ            reduce using rule 51 (te -> ID .)
    END             reduce using rule 51 (te -> ID .)
    END_DO          reduce using rule 51 (te -> ID .)
    WHILE           reduce using rule 51 (te -> ID .)
    ELSIF           reduce using rule 51 (te -> ID .)
    ELSE            reduce using rule 51 (te -> ID .)
    END_IF          reduce using rule 51 (te -> ID .)
    RPAREN          reduce using rule 51 (te -> ID .)
    COMMA           reduce using rule 51 (te -> ID .)
    LPAREN          shift and go to state 95


state 65

    (42) variable_matrix_assign -> ID ASSIGN expression_arith .
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ID              reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    PRINT           reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    IF              reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    DO              reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    CALL            reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    READ            reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END             reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_DO          reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    WHILE           reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ELSIF           reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ELSE            reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_IF          reduce using rule 42 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 66

    (47) expression_arith -> c .
    (48) c -> c . MULTIPLY te
    (49) c -> c . DIVIDE te

    PLUS            reduce using rule 47 (expression_arith -> c .)
    MINUS           reduce using rule 47 (expression_arith -> c .)
    EXIT            reduce using rule 47 (expression_arith -> c .)
    ID              reduce using rule 47 (expression_arith -> c .)
    PRINT           reduce using rule 47 (expression_arith -> c .)
    IF              reduce using rule 47 (expression_arith -> c .)
    DO              reduce using rule 47 (expression_arith -> c .)
    CALL            reduce using rule 47 (expression_arith -> c .)
    READ            reduce using rule 47 (expression_arith -> c .)
    END             reduce using rule 47 (expression_arith -> c .)
    END_DO          reduce using rule 47 (expression_arith -> c .)
    WHILE           reduce using rule 47 (expression_arith -> c .)
    ELSIF           reduce using rule 47 (expression_arith -> c .)
    ELSE            reduce using rule 47 (expression_arith -> c .)
    END_IF          reduce using rule 47 (expression_arith -> c .)
    RPAREN          reduce using rule 47 (expression_arith -> c .)
    COMMA           reduce using rule 47 (expression_arith -> c .)
    MULTIPLY        shift and go to state 98
    DIVIDE          shift and go to state 99


state 67

    (50) c -> te .

    MULTIPLY        reduce using rule 50 (c -> te .)
    DIVIDE          reduce using rule 50 (c -> te .)
    PLUS            reduce using rule 50 (c -> te .)
    MINUS           reduce using rule 50 (c -> te .)
    EXIT            reduce using rule 50 (c -> te .)
    ID              reduce using rule 50 (c -> te .)
    PRINT           reduce using rule 50 (c -> te .)
    IF              reduce using rule 50 (c -> te .)
    DO              reduce using rule 50 (c -> te .)
    CALL            reduce using rule 50 (c -> te .)
    READ            reduce using rule 50 (c -> te .)
    END             reduce using rule 50 (c -> te .)
    END_DO          reduce using rule 50 (c -> te .)
    WHILE           reduce using rule 50 (c -> te .)
    ELSIF           reduce using rule 50 (c -> te .)
    ELSE            reduce using rule 50 (c -> te .)
    END_IF          reduce using rule 50 (c -> te .)
    RPAREN          reduce using rule 50 (c -> te .)
    COMMA           reduce using rule 50 (c -> te .)


state 68

    (52) te -> constante_entero .

    MULTIPLY        reduce using rule 52 (te -> constante_entero .)
    DIVIDE          reduce using rule 52 (te -> constante_entero .)
    PLUS            reduce using rule 52 (te -> constante_entero .)
    MINUS           reduce using rule 52 (te -> constante_entero .)
    EXIT            reduce using rule 52 (te -> constante_entero .)
    ID              reduce using rule 52 (te -> constante_entero .)
    PRINT           reduce using rule 52 (te -> constante_entero .)
    IF              reduce using rule 52 (te -> constante_entero .)
    DO              reduce using rule 52 (te -> constante_entero .)
    CALL            reduce using rule 52 (te -> constante_entero .)
    READ            reduce using rule 52 (te -> constante_entero .)
    END             reduce using rule 52 (te -> constante_entero .)
    END_DO          reduce using rule 52 (te -> constante_entero .)
    WHILE           reduce using rule 52 (te -> constante_entero .)
    ELSIF           reduce using rule 52 (te -> constante_entero .)
    ELSE            reduce using rule 52 (te -> constante_entero .)
    END_IF          reduce using rule 52 (te -> constante_entero .)
    RPAREN          reduce using rule 52 (te -> constante_entero .)
    COMMA           reduce using rule 52 (te -> constante_entero .)


state 69

    (53) te -> constante_flotante .

    MULTIPLY        reduce using rule 53 (te -> constante_flotante .)
    DIVIDE          reduce using rule 53 (te -> constante_flotante .)
    PLUS            reduce using rule 53 (te -> constante_flotante .)
    MINUS           reduce using rule 53 (te -> constante_flotante .)
    EXIT            reduce using rule 53 (te -> constante_flotante .)
    ID              reduce using rule 53 (te -> constante_flotante .)
    PRINT           reduce using rule 53 (te -> constante_flotante .)
    IF              reduce using rule 53 (te -> constante_flotante .)
    DO              reduce using rule 53 (te -> constante_flotante .)
    CALL            reduce using rule 53 (te -> constante_flotante .)
    READ            reduce using rule 53 (te -> constante_flotante .)
    END             reduce using rule 53 (te -> constante_flotante .)
    END_DO          reduce using rule 53 (te -> constante_flotante .)
    WHILE           reduce using rule 53 (te -> constante_flotante .)
    ELSIF           reduce using rule 53 (te -> constante_flotante .)
    ELSE            reduce using rule 53 (te -> constante_flotante .)
    END_IF          reduce using rule 53 (te -> constante_flotante .)
    RPAREN          reduce using rule 53 (te -> constante_flotante .)
    COMMA           reduce using rule 53 (te -> constante_flotante .)


state 70

    (56) te -> LPAREN . expression_arith RPAREN
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 100
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 71

    (72) constante_flotante -> FLOAT .

    MULTIPLY        reduce using rule 72 (constante_flotante -> FLOAT .)
    DIVIDE          reduce using rule 72 (constante_flotante -> FLOAT .)
    PLUS            reduce using rule 72 (constante_flotante -> FLOAT .)
    MINUS           reduce using rule 72 (constante_flotante -> FLOAT .)
    EXIT            reduce using rule 72 (constante_flotante -> FLOAT .)
    ID              reduce using rule 72 (constante_flotante -> FLOAT .)
    PRINT           reduce using rule 72 (constante_flotante -> FLOAT .)
    IF              reduce using rule 72 (constante_flotante -> FLOAT .)
    DO              reduce using rule 72 (constante_flotante -> FLOAT .)
    CALL            reduce using rule 72 (constante_flotante -> FLOAT .)
    READ            reduce using rule 72 (constante_flotante -> FLOAT .)
    END             reduce using rule 72 (constante_flotante -> FLOAT .)
    END_DO          reduce using rule 72 (constante_flotante -> FLOAT .)
    WHILE           reduce using rule 72 (constante_flotante -> FLOAT .)
    ELSIF           reduce using rule 72 (constante_flotante -> FLOAT .)
    ELSE            reduce using rule 72 (constante_flotante -> FLOAT .)
    END_IF          reduce using rule 72 (constante_flotante -> FLOAT .)
    RPAREN          reduce using rule 72 (constante_flotante -> FLOAT .)
    COMMA           reduce using rule 72 (constante_flotante -> FLOAT .)


state 72

    (43) variable_matrix_assign -> ID LPAREN expression_arith . RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> ID LPAREN expression_arith . COMMA expression_arith RPAREN ASSIGN expression_arith
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 101
    COMMA           shift and go to state 102
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 73

    (40) printing_variables -> PRINT LPAREN expression_arith . RPAREN
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 103
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 74

    (41) printing_variables -> PRINT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 104


state 75

    (34) if_expression -> IF expression_logic crearCuadruploGoToF . THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> IF expression_logic crearCuadruploGoToF . THEN if_expression_local acabarIF END_IF

    THEN            shift and go to state 105


state 76

    (57) expression_logic -> expression_logic OR . g
    (59) g -> . g AND ge
    (60) g -> . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    g                              shift and go to state 106
    ge                             shift and go to state 47

state 77

    (68) crearCuadruploGoToF -> empty .

    THEN            reduce using rule 68 (crearCuadruploGoToF -> empty .)


state 78

    (59) g -> g AND . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    ge                             shift and go to state 107

state 79

    (61) ge -> ID GT . ID

    ID              shift and go to state 108


state 80

    (62) ge -> ID LT . ID

    ID              shift and go to state 109


state 81

    (63) ge -> ID GE . ID

    ID              shift and go to state 110


state 82

    (64) ge -> ID LE . ID

    ID              shift and go to state 111


state 83

    (65) ge -> ID NE . ID

    ID              shift and go to state 112


state 84

    (66) ge -> ID EQUAL . ID

    ID              shift and go to state 113


state 85

    (67) ge -> LPAREN expression_logic . RPAREN
    (57) expression_logic -> expression_logic . OR g

    RPAREN          shift and go to state 114
    OR              shift and go to state 76


state 86

    (30) do_loop -> DO LOOP d . END_DO

    END_DO          shift and go to state 115


state 87

    (28) do_contador -> DO ID COMMA . ID COMMA variable_matrix_assign d END_DO

    ID              shift and go to state 116


state 88

    (29) do_contador -> DO constante_entero COMMA . constante_entero COMMA variable_matrix_assign d END_DO
    (71) constante_entero -> . INT

    INT             shift and go to state 54

    constante_entero               shift and go to state 117

state 89

    (31) do_while_loop -> DO paso1DO LOOP . d WHILE expression_logic paso2DO END_DO
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    d                              shift and go to state 118
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 90

    (14) f_local -> SUBROUTINE ID d END SUBROUTINE . ID f_local
    (15) f_local -> SUBROUTINE ID d END SUBROUTINE . ID

    ID              shift and go to state 119


state 91

    (4) var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table . var_assign
    (4) var_assign -> . type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
    (5) var_assign -> . empty
    (2) type_definition -> . INT_TYPE
    (3) type_definition -> . FLOAT_TYPE
    (75) empty -> .

    INT_TYPE        shift and go to state 7
    FLOAT_TYPE      shift and go to state 8
    SUBROUTINE      reduce using rule 75 (empty -> .)
    BEGIN           reduce using rule 75 (empty -> .)

    type_definition                shift and go to state 5
    var_assign                     shift and go to state 120
    empty                          shift and go to state 6

state 92

    (9) create_var_table -> empty .

    INT_TYPE        reduce using rule 9 (create_var_table -> empty .)
    FLOAT_TYPE      reduce using rule 9 (create_var_table -> empty .)
    SUBROUTINE      reduce using rule 9 (create_var_table -> empty .)
    BEGIN           reduce using rule 9 (create_var_table -> empty .)


state 93

    (6) var_dimensiones -> LARR constante_entero . RARR
    (7) var_dimensiones -> LARR constante_entero . COMMA constante_entero RARR

    RARR            shift and go to state 121
    COMMA           shift and go to state 122


state 94

    (10) var_local -> ID COMMA var_local .

    LARR            reduce using rule 10 (var_local -> ID COMMA var_local .)
    INT_TYPE        reduce using rule 10 (var_local -> ID COMMA var_local .)
    FLOAT_TYPE      reduce using rule 10 (var_local -> ID COMMA var_local .)
    SUBROUTINE      reduce using rule 10 (var_local -> ID COMMA var_local .)
    BEGIN           reduce using rule 10 (var_local -> ID COMMA var_local .)


state 95

    (54) te -> ID LPAREN . expression_arith RPAREN
    (55) te -> ID LPAREN . expression_arith COMMA expression_arith RPAREN
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 123
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 96

    (45) expression_arith -> expression_arith PLUS . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    c                              shift and go to state 124
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 97

    (46) expression_arith -> expression_arith MINUS . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    c                              shift and go to state 125
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 98

    (48) c -> c MULTIPLY . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    te                             shift and go to state 126
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 99

    (49) c -> c DIVIDE . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    te                             shift and go to state 127
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 100

    (56) te -> LPAREN expression_arith . RPAREN
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 128
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 101

    (43) variable_matrix_assign -> ID LPAREN expression_arith RPAREN . ASSIGN expression_arith

    ASSIGN          shift and go to state 129


state 102

    (44) variable_matrix_assign -> ID LPAREN expression_arith COMMA . expression_arith RPAREN ASSIGN expression_arith
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 130
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 103

    (40) printing_variables -> PRINT LPAREN expression_arith RPAREN .

    EXIT            reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    ID              reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    PRINT           reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    IF              reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    DO              reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    CALL            reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    READ            reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    END             reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    END_DO          reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    WHILE           reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    ELSIF           reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    ELSE            reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)
    END_IF          reduce using rule 40 (printing_variables -> PRINT LPAREN expression_arith RPAREN .)


state 104

    (41) printing_variables -> PRINT LPAREN STRING RPAREN .

    EXIT            reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    ID              reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    PRINT           reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    IF              reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    DO              reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    CALL            reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    READ            reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    END             reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    END_DO          reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    WHILE           reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    ELSIF           reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    ELSE            reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)
    END_IF          reduce using rule 41 (printing_variables -> PRINT LPAREN STRING RPAREN .)


state 105

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN . if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> IF expression_logic crearCuadruploGoToF THEN . if_expression_local acabarIF END_IF
    (36) if_expression_local -> . d
    (37) if_expression_local -> . empty
    (17) d -> . b
    (18) d -> . b d
    (75) empty -> .
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    ELSIF           reduce using rule 75 (empty -> .)
    ELSE            reduce using rule 75 (empty -> .)
    END_IF          reduce using rule 75 (empty -> .)
    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    if_expression_local            shift and go to state 131
    d                              shift and go to state 132
    empty                          shift and go to state 133
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 106

    (57) expression_logic -> expression_logic OR g .
    (59) g -> g . AND ge

    OR              reduce using rule 57 (expression_logic -> expression_logic OR g .)
    THEN            reduce using rule 57 (expression_logic -> expression_logic OR g .)
    RPAREN          reduce using rule 57 (expression_logic -> expression_logic OR g .)
    END_DO          reduce using rule 57 (expression_logic -> expression_logic OR g .)
    AND             shift and go to state 78


state 107

    (59) g -> g AND ge .

    AND             reduce using rule 59 (g -> g AND ge .)
    OR              reduce using rule 59 (g -> g AND ge .)
    THEN            reduce using rule 59 (g -> g AND ge .)
    RPAREN          reduce using rule 59 (g -> g AND ge .)
    END_DO          reduce using rule 59 (g -> g AND ge .)


state 108

    (61) ge -> ID GT ID .

    AND             reduce using rule 61 (ge -> ID GT ID .)
    OR              reduce using rule 61 (ge -> ID GT ID .)
    THEN            reduce using rule 61 (ge -> ID GT ID .)
    RPAREN          reduce using rule 61 (ge -> ID GT ID .)
    END_DO          reduce using rule 61 (ge -> ID GT ID .)


state 109

    (62) ge -> ID LT ID .

    AND             reduce using rule 62 (ge -> ID LT ID .)
    OR              reduce using rule 62 (ge -> ID LT ID .)
    THEN            reduce using rule 62 (ge -> ID LT ID .)
    RPAREN          reduce using rule 62 (ge -> ID LT ID .)
    END_DO          reduce using rule 62 (ge -> ID LT ID .)


state 110

    (63) ge -> ID GE ID .

    AND             reduce using rule 63 (ge -> ID GE ID .)
    OR              reduce using rule 63 (ge -> ID GE ID .)
    THEN            reduce using rule 63 (ge -> ID GE ID .)
    RPAREN          reduce using rule 63 (ge -> ID GE ID .)
    END_DO          reduce using rule 63 (ge -> ID GE ID .)


state 111

    (64) ge -> ID LE ID .

    AND             reduce using rule 64 (ge -> ID LE ID .)
    OR              reduce using rule 64 (ge -> ID LE ID .)
    THEN            reduce using rule 64 (ge -> ID LE ID .)
    RPAREN          reduce using rule 64 (ge -> ID LE ID .)
    END_DO          reduce using rule 64 (ge -> ID LE ID .)


state 112

    (65) ge -> ID NE ID .

    AND             reduce using rule 65 (ge -> ID NE ID .)
    OR              reduce using rule 65 (ge -> ID NE ID .)
    THEN            reduce using rule 65 (ge -> ID NE ID .)
    RPAREN          reduce using rule 65 (ge -> ID NE ID .)
    END_DO          reduce using rule 65 (ge -> ID NE ID .)


state 113

    (66) ge -> ID EQUAL ID .

    AND             reduce using rule 66 (ge -> ID EQUAL ID .)
    OR              reduce using rule 66 (ge -> ID EQUAL ID .)
    THEN            reduce using rule 66 (ge -> ID EQUAL ID .)
    RPAREN          reduce using rule 66 (ge -> ID EQUAL ID .)
    END_DO          reduce using rule 66 (ge -> ID EQUAL ID .)


state 114

    (67) ge -> LPAREN expression_logic RPAREN .

    AND             reduce using rule 67 (ge -> LPAREN expression_logic RPAREN .)
    OR              reduce using rule 67 (ge -> LPAREN expression_logic RPAREN .)
    THEN            reduce using rule 67 (ge -> LPAREN expression_logic RPAREN .)
    RPAREN          reduce using rule 67 (ge -> LPAREN expression_logic RPAREN .)
    END_DO          reduce using rule 67 (ge -> LPAREN expression_logic RPAREN .)


state 115

    (30) do_loop -> DO LOOP d END_DO .

    EXIT            reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    ID              reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    PRINT           reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    IF              reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    DO              reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    CALL            reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    READ            reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    END             reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    END_DO          reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    WHILE           reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    ELSIF           reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    ELSE            reduce using rule 30 (do_loop -> DO LOOP d END_DO .)
    END_IF          reduce using rule 30 (do_loop -> DO LOOP d END_DO .)


state 116

    (28) do_contador -> DO ID COMMA ID . COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 134


state 117

    (29) do_contador -> DO constante_entero COMMA constante_entero . COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 135


state 118

    (31) do_while_loop -> DO paso1DO LOOP d . WHILE expression_logic paso2DO END_DO

    WHILE           shift and go to state 136


state 119

    (14) f_local -> SUBROUTINE ID d END SUBROUTINE ID . f_local
    (15) f_local -> SUBROUTINE ID d END SUBROUTINE ID .
    (14) f_local -> . SUBROUTINE ID d END SUBROUTINE ID f_local
    (15) f_local -> . SUBROUTINE ID d END SUBROUTINE ID

    BEGIN           reduce using rule 15 (f_local -> SUBROUTINE ID d END SUBROUTINE ID .)
    SUBROUTINE      shift and go to state 12

    f_local                        shift and go to state 137

state 120

    (4) var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .

    SUBROUTINE      reduce using rule 4 (var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .)
    BEGIN           reduce using rule 4 (var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .)


state 121

    (6) var_dimensiones -> LARR constante_entero RARR .

    INT_TYPE        reduce using rule 6 (var_dimensiones -> LARR constante_entero RARR .)
    FLOAT_TYPE      reduce using rule 6 (var_dimensiones -> LARR constante_entero RARR .)
    SUBROUTINE      reduce using rule 6 (var_dimensiones -> LARR constante_entero RARR .)
    BEGIN           reduce using rule 6 (var_dimensiones -> LARR constante_entero RARR .)


state 122

    (7) var_dimensiones -> LARR constante_entero COMMA . constante_entero RARR
    (71) constante_entero -> . INT

    INT             shift and go to state 54

    constante_entero               shift and go to state 138

state 123

    (54) te -> ID LPAREN expression_arith . RPAREN
    (55) te -> ID LPAREN expression_arith . COMMA expression_arith RPAREN
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 139
    COMMA           shift and go to state 140
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 124

    (45) expression_arith -> expression_arith PLUS c .
    (48) c -> c . MULTIPLY te
    (49) c -> c . DIVIDE te

    PLUS            reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    MINUS           reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    EXIT            reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    ID              reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    PRINT           reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    IF              reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    DO              reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    CALL            reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    READ            reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    END             reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    END_DO          reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    WHILE           reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    ELSIF           reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    ELSE            reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    END_IF          reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    RPAREN          reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    COMMA           reduce using rule 45 (expression_arith -> expression_arith PLUS c .)
    MULTIPLY        shift and go to state 98
    DIVIDE          shift and go to state 99


state 125

    (46) expression_arith -> expression_arith MINUS c .
    (48) c -> c . MULTIPLY te
    (49) c -> c . DIVIDE te

    PLUS            reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    MINUS           reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    EXIT            reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    ID              reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    PRINT           reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    IF              reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    DO              reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    CALL            reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    READ            reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    END             reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    END_DO          reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    WHILE           reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    ELSIF           reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    ELSE            reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    END_IF          reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    RPAREN          reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    COMMA           reduce using rule 46 (expression_arith -> expression_arith MINUS c .)
    MULTIPLY        shift and go to state 98
    DIVIDE          shift and go to state 99


state 126

    (48) c -> c MULTIPLY te .

    MULTIPLY        reduce using rule 48 (c -> c MULTIPLY te .)
    DIVIDE          reduce using rule 48 (c -> c MULTIPLY te .)
    PLUS            reduce using rule 48 (c -> c MULTIPLY te .)
    MINUS           reduce using rule 48 (c -> c MULTIPLY te .)
    EXIT            reduce using rule 48 (c -> c MULTIPLY te .)
    ID              reduce using rule 48 (c -> c MULTIPLY te .)
    PRINT           reduce using rule 48 (c -> c MULTIPLY te .)
    IF              reduce using rule 48 (c -> c MULTIPLY te .)
    DO              reduce using rule 48 (c -> c MULTIPLY te .)
    CALL            reduce using rule 48 (c -> c MULTIPLY te .)
    READ            reduce using rule 48 (c -> c MULTIPLY te .)
    END             reduce using rule 48 (c -> c MULTIPLY te .)
    END_DO          reduce using rule 48 (c -> c MULTIPLY te .)
    WHILE           reduce using rule 48 (c -> c MULTIPLY te .)
    ELSIF           reduce using rule 48 (c -> c MULTIPLY te .)
    ELSE            reduce using rule 48 (c -> c MULTIPLY te .)
    END_IF          reduce using rule 48 (c -> c MULTIPLY te .)
    RPAREN          reduce using rule 48 (c -> c MULTIPLY te .)
    COMMA           reduce using rule 48 (c -> c MULTIPLY te .)


state 127

    (49) c -> c DIVIDE te .

    MULTIPLY        reduce using rule 49 (c -> c DIVIDE te .)
    DIVIDE          reduce using rule 49 (c -> c DIVIDE te .)
    PLUS            reduce using rule 49 (c -> c DIVIDE te .)
    MINUS           reduce using rule 49 (c -> c DIVIDE te .)
    EXIT            reduce using rule 49 (c -> c DIVIDE te .)
    ID              reduce using rule 49 (c -> c DIVIDE te .)
    PRINT           reduce using rule 49 (c -> c DIVIDE te .)
    IF              reduce using rule 49 (c -> c DIVIDE te .)
    DO              reduce using rule 49 (c -> c DIVIDE te .)
    CALL            reduce using rule 49 (c -> c DIVIDE te .)
    READ            reduce using rule 49 (c -> c DIVIDE te .)
    END             reduce using rule 49 (c -> c DIVIDE te .)
    END_DO          reduce using rule 49 (c -> c DIVIDE te .)
    WHILE           reduce using rule 49 (c -> c DIVIDE te .)
    ELSIF           reduce using rule 49 (c -> c DIVIDE te .)
    ELSE            reduce using rule 49 (c -> c DIVIDE te .)
    END_IF          reduce using rule 49 (c -> c DIVIDE te .)
    RPAREN          reduce using rule 49 (c -> c DIVIDE te .)
    COMMA           reduce using rule 49 (c -> c DIVIDE te .)


state 128

    (56) te -> LPAREN expression_arith RPAREN .

    MULTIPLY        reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    DIVIDE          reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    PLUS            reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    MINUS           reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    EXIT            reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    ID              reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    PRINT           reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    IF              reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    DO              reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    CALL            reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    READ            reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    END             reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    END_DO          reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    WHILE           reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    ELSIF           reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    ELSE            reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    END_IF          reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    RPAREN          reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)
    COMMA           reduce using rule 56 (te -> LPAREN expression_arith RPAREN .)


state 129

    (43) variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN . expression_arith
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 141
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 130

    (44) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith . RPAREN ASSIGN expression_arith
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 142
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 131

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local . if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local . acabarIF END_IF
    (38) if_expression_local2 -> . ELSIF expression_logic THEN if_expression_local if_expression_local2
    (39) if_expression_local2 -> . empty
    (70) acabarIF -> . empty
    (75) empty -> .

    ELSIF           shift and go to state 145
    ELSE            reduce using rule 75 (empty -> .)
    END_IF          reduce using rule 75 (empty -> .)

    if_expression_local2           shift and go to state 143
    acabarIF                       shift and go to state 144
    empty                          shift and go to state 146

state 132

    (36) if_expression_local -> d .

    ELSIF           reduce using rule 36 (if_expression_local -> d .)
    ELSE            reduce using rule 36 (if_expression_local -> d .)
    END_IF          reduce using rule 36 (if_expression_local -> d .)


state 133

    (37) if_expression_local -> empty .

    ELSIF           reduce using rule 37 (if_expression_local -> empty .)
    ELSE            reduce using rule 37 (if_expression_local -> empty .)
    END_IF          reduce using rule 37 (if_expression_local -> empty .)


state 134

    (28) do_contador -> DO ID COMMA ID COMMA . variable_matrix_assign d END_DO
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith

    ID              shift and go to state 30

    variable_matrix_assign         shift and go to state 147

state 135

    (29) do_contador -> DO constante_entero COMMA constante_entero COMMA . variable_matrix_assign d END_DO
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith

    ID              shift and go to state 30

    variable_matrix_assign         shift and go to state 148

state 136

    (31) do_while_loop -> DO paso1DO LOOP d WHILE . expression_logic paso2DO END_DO
    (57) expression_logic -> . expression_logic OR g
    (58) expression_logic -> . g
    (59) g -> . g AND ge
    (60) g -> . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    expression_logic               shift and go to state 149
    g                              shift and go to state 46
    ge                             shift and go to state 47

state 137

    (14) f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local .

    BEGIN           reduce using rule 14 (f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local .)


state 138

    (7) var_dimensiones -> LARR constante_entero COMMA constante_entero . RARR

    RARR            shift and go to state 150


state 139

    (54) te -> ID LPAREN expression_arith RPAREN .

    MULTIPLY        reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    DIVIDE          reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    PLUS            reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    MINUS           reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    EXIT            reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    ID              reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    PRINT           reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    IF              reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    DO              reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    CALL            reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    READ            reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    END             reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    END_DO          reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    WHILE           reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    ELSIF           reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    ELSE            reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    END_IF          reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    RPAREN          reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)
    COMMA           reduce using rule 54 (te -> ID LPAREN expression_arith RPAREN .)


state 140

    (55) te -> ID LPAREN expression_arith COMMA . expression_arith RPAREN
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 151
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 141

    (43) variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ID              reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    PRINT           reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    IF              reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    DO              reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    CALL            reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    READ            reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END             reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_DO          reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    WHILE           reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ELSIF           reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ELSE            reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_IF          reduce using rule 43 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 142

    (44) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN . ASSIGN expression_arith

    ASSIGN          shift and go to state 152


state 143

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 . crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (69) crearCuadruploGoTo -> . empty
    (75) empty -> .

    ELSE            reduce using rule 75 (empty -> .)

    crearCuadruploGoTo             shift and go to state 153
    empty                          shift and go to state 154

state 144

    (35) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF . END_IF

    END_IF          shift and go to state 155


state 145

    (38) if_expression_local2 -> ELSIF . expression_logic THEN if_expression_local if_expression_local2
    (57) expression_logic -> . expression_logic OR g
    (58) expression_logic -> . g
    (59) g -> . g AND ge
    (60) g -> . ge
    (61) ge -> . ID GT ID
    (62) ge -> . ID LT ID
    (63) ge -> . ID GE ID
    (64) ge -> . ID LE ID
    (65) ge -> . ID NE ID
    (66) ge -> . ID EQUAL ID
    (67) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 48
    LPAREN          shift and go to state 49

    expression_logic               shift and go to state 156
    g                              shift and go to state 46
    ge                             shift and go to state 47

state 146

    (39) if_expression_local2 -> empty .
    (70) acabarIF -> empty .

    ELSE            reduce using rule 39 (if_expression_local2 -> empty .)
    END_IF          reduce using rule 70 (acabarIF -> empty .)


state 147

    (28) do_contador -> DO ID COMMA ID COMMA variable_matrix_assign . d END_DO
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    variable_matrix_assign         shift and go to state 21
    d                              shift and go to state 157
    b                              shift and go to state 20
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 148

    (29) do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign . d END_DO
    (17) d -> . b
    (18) d -> . b d
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    variable_matrix_assign         shift and go to state 21
    d                              shift and go to state 158
    b                              shift and go to state 20
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 149

    (31) do_while_loop -> DO paso1DO LOOP d WHILE expression_logic . paso2DO END_DO
    (57) expression_logic -> expression_logic . OR g
    (74) paso2DO -> . empty
    (75) empty -> .

    OR              shift and go to state 76
    END_DO          reduce using rule 75 (empty -> .)

    paso2DO                        shift and go to state 159
    empty                          shift and go to state 160

state 150

    (7) var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .

    INT_TYPE        reduce using rule 7 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    FLOAT_TYPE      reduce using rule 7 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    SUBROUTINE      reduce using rule 7 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    BEGIN           reduce using rule 7 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)


state 151

    (55) te -> ID LPAREN expression_arith COMMA expression_arith . RPAREN
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 161
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 152

    (44) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN . expression_arith
    (45) expression_arith -> . expression_arith PLUS c
    (46) expression_arith -> . expression_arith MINUS c
    (47) expression_arith -> . c
    (48) c -> . c MULTIPLY te
    (49) c -> . c DIVIDE te
    (50) c -> . te
    (51) te -> . ID
    (52) te -> . constante_entero
    (53) te -> . constante_flotante
    (54) te -> . ID LPAREN expression_arith RPAREN
    (55) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (56) te -> . LPAREN expression_arith RPAREN
    (71) constante_entero -> . INT
    (72) constante_flotante -> . FLOAT

    ID              shift and go to state 64
    LPAREN          shift and go to state 70
    INT             shift and go to state 54
    FLOAT           shift and go to state 71

    expression_arith               shift and go to state 162
    c                              shift and go to state 66
    te                             shift and go to state 67
    constante_entero               shift and go to state 68
    constante_flotante             shift and go to state 69

state 153

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo . ELSE if_expression_local acabarIF END_IF

    ELSE            shift and go to state 163


state 154

    (69) crearCuadruploGoTo -> empty .

    ELSE            reduce using rule 69 (crearCuadruploGoTo -> empty .)


state 155

    (35) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .

    EXIT            reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    ID              reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    PRINT           reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    IF              reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    DO              reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    CALL            reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    READ            reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    END             reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    END_DO          reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    WHILE           reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    ELSIF           reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    ELSE            reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)
    END_IF          reduce using rule 35 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF .)


state 156

    (38) if_expression_local2 -> ELSIF expression_logic . THEN if_expression_local if_expression_local2
    (57) expression_logic -> expression_logic . OR g

    THEN            shift and go to state 164
    OR              shift and go to state 76


state 157

    (28) do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d . END_DO

    END_DO          shift and go to state 165


state 158

    (29) do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d . END_DO

    END_DO          shift and go to state 166


state 159

    (31) do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO . END_DO

    END_DO          shift and go to state 167


state 160

    (74) paso2DO -> empty .

    END_DO          reduce using rule 74 (paso2DO -> empty .)


state 161

    (55) te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .

    MULTIPLY        reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    DIVIDE          reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    PLUS            reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    MINUS           reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    EXIT            reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ID              reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    PRINT           reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    IF              reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    DO              reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    CALL            reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    READ            reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END             reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_DO          reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    WHILE           reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ELSIF           reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ELSE            reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_IF          reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    RPAREN          reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    COMMA           reduce using rule 55 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)


state 162

    (44) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .
    (45) expression_arith -> expression_arith . PLUS c
    (46) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ID              reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    PRINT           reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    IF              reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    DO              reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    CALL            reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    READ            reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END             reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_DO          reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    WHILE           reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ELSIF           reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ELSE            reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_IF          reduce using rule 44 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    PLUS            shift and go to state 96
    MINUS           shift and go to state 97


state 163

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE . if_expression_local acabarIF END_IF
    (36) if_expression_local -> . d
    (37) if_expression_local -> . empty
    (17) d -> . b
    (18) d -> . b d
    (75) empty -> .
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    END_IF          reduce using rule 75 (empty -> .)
    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    if_expression_local            shift and go to state 168
    d                              shift and go to state 132
    empty                          shift and go to state 133
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 164

    (38) if_expression_local2 -> ELSIF expression_logic THEN . if_expression_local if_expression_local2
    (36) if_expression_local -> . d
    (37) if_expression_local -> . empty
    (17) d -> . b
    (18) d -> . b d
    (75) empty -> .
    (19) b -> . variable_matrix_assign
    (20) b -> . printing_variables
    (21) b -> . if_expression
    (22) b -> . do_loop
    (23) b -> . do_contador
    (24) b -> . do_while_loop
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT
    (42) variable_matrix_assign -> . ID ASSIGN expression_arith
    (43) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (44) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (40) printing_variables -> . PRINT LPAREN expression_arith RPAREN
    (41) printing_variables -> . PRINT LPAREN STRING RPAREN
    (34) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF
    (35) if_expression -> . IF expression_logic crearCuadruploGoToF THEN if_expression_local acabarIF END_IF
    (30) do_loop -> . DO LOOP d END_DO
    (28) do_contador -> . DO ID COMMA ID COMMA variable_matrix_assign d END_DO
    (29) do_contador -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (31) do_while_loop -> . DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO
    (33) call_subroutine -> . CALL ID
    (32) reading_variables -> . READ ID

    ELSIF           reduce using rule 75 (empty -> .)
    ELSE            reduce using rule 75 (empty -> .)
    EXIT            shift and go to state 29
    ID              shift and go to state 30
    PRINT           shift and go to state 31
    IF              shift and go to state 32
    DO              shift and go to state 33
    CALL            shift and go to state 34
    READ            shift and go to state 35

    if_expression_local            shift and go to state 169
    d                              shift and go to state 132
    empty                          shift and go to state 133
    b                              shift and go to state 20
    variable_matrix_assign         shift and go to state 21
    printing_variables             shift and go to state 22
    if_expression                  shift and go to state 23
    do_loop                        shift and go to state 24
    do_contador                    shift and go to state 25
    do_while_loop                  shift and go to state 26
    call_subroutine                shift and go to state 27
    reading_variables              shift and go to state 28

state 165

    (28) do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .

    EXIT            reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    ID              reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    PRINT           reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    IF              reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    DO              reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    CALL            reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    READ            reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    END             reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    END_DO          reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    WHILE           reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    ELSIF           reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    ELSE            reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)
    END_IF          reduce using rule 28 (do_contador -> DO ID COMMA ID COMMA variable_matrix_assign d END_DO .)


state 166

    (29) do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .

    EXIT            reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ID              reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    PRINT           reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    IF              reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    DO              reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    CALL            reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    READ            reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END             reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_DO          reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    WHILE           reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ELSIF           reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ELSE            reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_IF          reduce using rule 29 (do_contador -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)


state 167

    (31) do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .

    EXIT            reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    ID              reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    PRINT           reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    IF              reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    DO              reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    CALL            reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    READ            reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    END             reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    END_DO          reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    WHILE           reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    ELSIF           reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    ELSE            reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)
    END_IF          reduce using rule 31 (do_while_loop -> DO paso1DO LOOP d WHILE expression_logic paso2DO END_DO .)


state 168

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local . acabarIF END_IF
    (70) acabarIF -> . empty
    (75) empty -> .

    END_IF          reduce using rule 75 (empty -> .)

    acabarIF                       shift and go to state 170
    empty                          shift and go to state 171

state 169

    (38) if_expression_local2 -> ELSIF expression_logic THEN if_expression_local . if_expression_local2
    (38) if_expression_local2 -> . ELSIF expression_logic THEN if_expression_local if_expression_local2
    (39) if_expression_local2 -> . empty
    (75) empty -> .

    ELSIF           shift and go to state 145
    ELSE            reduce using rule 75 (empty -> .)

    if_expression_local2           shift and go to state 172
    empty                          shift and go to state 173

state 170

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF . END_IF

    END_IF          shift and go to state 174


state 171

    (70) acabarIF -> empty .

    END_IF          reduce using rule 70 (acabarIF -> empty .)


state 172

    (38) if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2 .

    ELSE            reduce using rule 38 (if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2 .)


state 173

    (39) if_expression_local2 -> empty .

    ELSE            reduce using rule 39 (if_expression_local2 -> empty .)


state 174

    (34) if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .

    EXIT            reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    ID              reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    PRINT           reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    IF              reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    DO              reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    CALL            reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    READ            reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    END             reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    END_DO          reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    WHILE           reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    ELSIF           reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    ELSE            reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)
    END_IF          reduce using rule 34 (if_expression -> IF expression_logic crearCuadruploGoToF THEN if_expression_local if_expression_local2 crearCuadruploGoTo ELSE if_expression_local acabarIF END_IF .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LOOP in state 33 resolved as shift
