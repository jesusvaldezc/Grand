Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    LBRACK
    QMARKS
    RBRACK
    STRING
    UMINUS

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID
Rule 2     primerCuad -> empty
Rule 3     rellenaCuad -> empty
Rule 4     type_definition -> INT_TYPE
Rule 5     type_definition -> FLOAT_TYPE
Rule 6     var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
Rule 7     var_assign -> empty
Rule 8     var_dimensiones -> LARR constante_entero RARR
Rule 9     var_dimensiones -> LARR constante_entero COMMA constante_entero RARR
Rule 10    var_dimensiones -> empty
Rule 11    create_var_table -> empty
Rule 12    var_local -> ID COMMA var_local
Rule 13    var_local -> ID
Rule 14    subrutinas -> f_local
Rule 15    subrutinas -> empty
Rule 16    f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local
Rule 17    f_local -> SUBROUTINE ID d END SUBROUTINE ID
Rule 18    a -> BEGIN d END
Rule 19    d -> b
Rule 20    d -> b d
Rule 21    b -> variable_matrix_assign
Rule 22    b -> printing_variables
Rule 23    b -> if_expression
Rule 24    b -> do_loops
Rule 25    b -> call_subroutine
Rule 26    b -> reading_variables
Rule 27    b -> EXIT paso4DoExit
Rule 28    do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
Rule 29    do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
Rule 30    do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
Rule 31    do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
Rule 32    paso1FOR -> ID
Rule 33    paso2FOR -> empty
Rule 34    paso3FOR -> empty
Rule 35    paso4FOR -> empty
Rule 36    reading_variables -> READ idrepInput
Rule 37    idrepInput -> idInput
Rule 38    idrepInput -> idInput COMMA idrepInput
Rule 39    idInput -> ID
Rule 40    call_subroutine -> CALL ID
Rule 41    if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
Rule 42    if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
Rule 43    if_expression_local -> d
Rule 44    if_expression_local -> empty
Rule 45    if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2
Rule 46    if_expression_local2 -> empty
Rule 47    printing_variables -> PRINT Output
Rule 48    Output -> idOut
Rule 49    Output -> LPAREN StringOut RPAREN
Rule 50    StringOut -> empty
Rule 51    StringOut -> ID StringOut
Rule 52    StringOut -> constante_entero StringOut
Rule 53    StringOut -> constante_flotante StringOut
Rule 54    StringOut -> COLONS StringOut
Rule 55    StringOut -> COMMA StringOut
Rule 56    StringOut -> QUESTION StringOut
Rule 57    idOut -> ID
Rule 58    variable_matrix_assign -> ID ASSIGN expression_arith
Rule 59    variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith
Rule 60    variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
Rule 61    expression_arith -> expression_arith PLUS c
Rule 62    expression_arith -> expression_arith MINUS c
Rule 63    expression_arith -> c
Rule 64    c -> c MULTIPLY te
Rule 65    c -> c DIVIDE te
Rule 66    c -> te
Rule 67    te -> ID
Rule 68    te -> constante_entero
Rule 69    te -> constante_flotante
Rule 70    te -> ID LPAREN expression_arith RPAREN
Rule 71    te -> ID LPAREN expression_arith COMMA expression_arith RPAREN
Rule 72    te -> LPAREN expression_arith RPAREN
Rule 73    expression_logic -> expression_logic OR g
Rule 74    expression_logic -> g
Rule 75    g -> g AND ge
Rule 76    g -> ge
Rule 77    ge -> ID GT ID
Rule 78    ge -> ID LT ID
Rule 79    ge -> ID GE ID
Rule 80    ge -> ID LE ID
Rule 81    ge -> ID NE ID
Rule 82    ge -> ID EQUAL ID
Rule 83    ge -> LPAREN expression_logic RPAREN
Rule 84    paso1IF -> empty
Rule 85    paso2IF -> empty
Rule 86    paso3IF -> empty
Rule 87    constante_entero -> INT
Rule 88    constante_flotante -> FLOAT
Rule 89    paso1DO -> empty
Rule 90    paso2DO -> empty
Rule 91    paso1DoExit -> empty
Rule 92    paso2DoExit -> empty
Rule 93    paso3DoExit -> empty
Rule 94    paso4DoExit -> empty
Rule 95    empty -> <empty>

Terminals, with rules where they appear

AND                  : 75
ASSIGN               : 28 58 59 60
BEGIN                : 18
CALL                 : 40
COLONS               : 6 6 54
COMMA                : 9 12 28 29 29 38 55 60 71
COMMENT              : 
DIVIDE               : 65
DO                   : 28 29 30
ELSE                 : 41
ELSIF                : 45
END                  : 1 16 17 18
END_DO               : 29 30
END_FOR              : 28
END_IF               : 41 42
END_LOOP             : 31
EQUAL                : 82
EXIT                 : 27
FLOAT                : 88
FLOAT_TYPE           : 5
FOR                  : 28
GE                   : 79
GT                   : 77
ID                   : 1 1 12 13 16 16 17 17 32 39 40 51 57 58 59 60 67 70 71 77 77 78 78 79 79 80 80 81 81 82 82
IF                   : 41 42
INT                  : 87
INT_TYPE             : 4
LARR                 : 8 9
LBRACK               : 
LE                   : 80
LOOP                 : 30 31
LPAREN               : 49 59 60 70 71 72 83
LT                   : 78
MINUS                : 62
MULTIPLY             : 64
NE                   : 81
OR                   : 73
PLUS                 : 61
PRINT                : 47
PROGRAM              : 1 1
QMARKS               : 
QUESTION             : 56
RARR                 : 8 9
RBRACK               : 
READ                 : 36
RPAREN               : 49 59 60 70 71 72 83
STRING               : 
SUBROUTINE           : 16 16 17 17
THEN                 : 41 42 45
UMINUS               : 
WHILE                : 30
error                : 

Nonterminals, with rules where they appear

Output               : 47
StringOut            : 49 51 52 53 54 55 56
a                    : 1
b                    : 19 20
c                    : 61 62 63 64 65
call_subroutine      : 25
constante_entero     : 8 9 9 29 29 52 68
constante_flotante   : 53 69
create_var_table     : 6
d                    : 16 17 18 20 28 29 30 31 43
do_loops             : 24
empty                : 2 3 7 10 11 15 33 34 35 44 46 50 84 85 86 89 90 91 92 93 94
expression_arith     : 28 28 58 59 59 60 60 60 61 62 70 71 71 72
expression_logic     : 30 41 42 45 73 83
f_local              : 14 16
g                    : 73 74 75
ge                   : 75 76
idInput              : 37 38
idOut                : 48
idrepInput           : 36 38
if_expression        : 23
if_expression_local  : 41 41 42 45
if_expression_local2 : 41 45
paso1DO              : 30
paso1DoExit          : 31
paso1FOR             : 28
paso1IF              : 41 42
paso2DO              : 30
paso2DoExit          : 31
paso2FOR             : 28
paso2IF              : 41
paso3DoExit          : 31
paso3FOR             : 28
paso3IF              : 41 42
paso4DoExit          : 27
paso4FOR             : 28
primerCuad           : 1
printing_variables   : 22
program              : 0
reading_variables    : 26
rellenaCuad          : 1
subrutinas           : 1
te                   : 64 65 66
type_definition      : 6
var_assign           : 1 6
var_dimensiones      : 6
var_local            : 6 12
variable_matrix_assign : 21 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID
    (2) primerCuad -> . empty
    (95) empty -> .

    INT_TYPE        reduce using rule 95 (empty -> .)
    FLOAT_TYPE      reduce using rule 95 (empty -> .)
    SUBROUTINE      reduce using rule 95 (empty -> .)
    BEGIN           reduce using rule 95 (empty -> .)

    primerCuad                     shift and go to state 4
    empty                          shift and go to state 5

state 4

    (1) program -> PROGRAM ID primerCuad . var_assign subrutinas rellenaCuad a END PROGRAM ID
    (6) var_assign -> . type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
    (7) var_assign -> . empty
    (4) type_definition -> . INT_TYPE
    (5) type_definition -> . FLOAT_TYPE
    (95) empty -> .

    INT_TYPE        shift and go to state 9
    FLOAT_TYPE      shift and go to state 10
    SUBROUTINE      reduce using rule 95 (empty -> .)
    BEGIN           reduce using rule 95 (empty -> .)

    var_assign                     shift and go to state 6
    type_definition                shift and go to state 7
    empty                          shift and go to state 8

state 5

    (2) primerCuad -> empty .

    INT_TYPE        reduce using rule 2 (primerCuad -> empty .)
    FLOAT_TYPE      reduce using rule 2 (primerCuad -> empty .)
    SUBROUTINE      reduce using rule 2 (primerCuad -> empty .)
    BEGIN           reduce using rule 2 (primerCuad -> empty .)


state 6

    (1) program -> PROGRAM ID primerCuad var_assign . subrutinas rellenaCuad a END PROGRAM ID
    (14) subrutinas -> . f_local
    (15) subrutinas -> . empty
    (16) f_local -> . SUBROUTINE ID d END SUBROUTINE ID f_local
    (17) f_local -> . SUBROUTINE ID d END SUBROUTINE ID
    (95) empty -> .

    SUBROUTINE      shift and go to state 14
    BEGIN           reduce using rule 95 (empty -> .)

    subrutinas                     shift and go to state 11
    f_local                        shift and go to state 12
    empty                          shift and go to state 13

state 7

    (6) var_assign -> type_definition . COLONS COLONS var_local var_dimensiones create_var_table var_assign

    COLONS          shift and go to state 15


state 8

    (7) var_assign -> empty .

    SUBROUTINE      reduce using rule 7 (var_assign -> empty .)
    BEGIN           reduce using rule 7 (var_assign -> empty .)


state 9

    (4) type_definition -> INT_TYPE .

    COLONS          reduce using rule 4 (type_definition -> INT_TYPE .)


state 10

    (5) type_definition -> FLOAT_TYPE .

    COLONS          reduce using rule 5 (type_definition -> FLOAT_TYPE .)


state 11

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas . rellenaCuad a END PROGRAM ID
    (3) rellenaCuad -> . empty
    (95) empty -> .

    BEGIN           reduce using rule 95 (empty -> .)

    rellenaCuad                    shift and go to state 16
    empty                          shift and go to state 17

state 12

    (14) subrutinas -> f_local .

    BEGIN           reduce using rule 14 (subrutinas -> f_local .)


state 13

    (15) subrutinas -> empty .

    BEGIN           reduce using rule 15 (subrutinas -> empty .)


state 14

    (16) f_local -> SUBROUTINE . ID d END SUBROUTINE ID f_local
    (17) f_local -> SUBROUTINE . ID d END SUBROUTINE ID

    ID              shift and go to state 18


state 15

    (6) var_assign -> type_definition COLONS . COLONS var_local var_dimensiones create_var_table var_assign

    COLONS          shift and go to state 19


state 16

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad . a END PROGRAM ID
    (18) a -> . BEGIN d END

    BEGIN           shift and go to state 21

    a                              shift and go to state 20

state 17

    (3) rellenaCuad -> empty .

    BEGIN           reduce using rule 3 (rellenaCuad -> empty .)


state 18

    (16) f_local -> SUBROUTINE ID . d END SUBROUTINE ID f_local
    (17) f_local -> SUBROUTINE ID . d END SUBROUTINE ID
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    d                              shift and go to state 23
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 19

    (6) var_assign -> type_definition COLONS COLONS . var_local var_dimensiones create_var_table var_assign
    (12) var_local -> . ID COMMA var_local
    (13) var_local -> . ID

    ID              shift and go to state 40

    var_local                      shift and go to state 39

state 20

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a . END PROGRAM ID

    END             shift and go to state 41


state 21

    (18) a -> BEGIN . d END
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    d                              shift and go to state 42
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 22

    (58) variable_matrix_assign -> ID . ASSIGN expression_arith
    (59) variable_matrix_assign -> ID . LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> ID . LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith

    ASSIGN          shift and go to state 43
    LPAREN          shift and go to state 44


state 23

    (16) f_local -> SUBROUTINE ID d . END SUBROUTINE ID f_local
    (17) f_local -> SUBROUTINE ID d . END SUBROUTINE ID

    END             shift and go to state 45


state 24

    (19) d -> b .
    (20) d -> b . d
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    END             reduce using rule 19 (d -> b .)
    END_LOOP        reduce using rule 19 (d -> b .)
    WHILE           reduce using rule 19 (d -> b .)
    ELSIF           reduce using rule 19 (d -> b .)
    ELSE            reduce using rule 19 (d -> b .)
    END_IF          reduce using rule 19 (d -> b .)
    END_DO          reduce using rule 19 (d -> b .)
    END_FOR         reduce using rule 19 (d -> b .)
    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    b                              shift and go to state 24
    d                              shift and go to state 46
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 25

    (21) b -> variable_matrix_assign .

    EXIT            reduce using rule 21 (b -> variable_matrix_assign .)
    ID              reduce using rule 21 (b -> variable_matrix_assign .)
    PRINT           reduce using rule 21 (b -> variable_matrix_assign .)
    IF              reduce using rule 21 (b -> variable_matrix_assign .)
    FOR             reduce using rule 21 (b -> variable_matrix_assign .)
    DO              reduce using rule 21 (b -> variable_matrix_assign .)
    LOOP            reduce using rule 21 (b -> variable_matrix_assign .)
    CALL            reduce using rule 21 (b -> variable_matrix_assign .)
    READ            reduce using rule 21 (b -> variable_matrix_assign .)
    END             reduce using rule 21 (b -> variable_matrix_assign .)
    END_LOOP        reduce using rule 21 (b -> variable_matrix_assign .)
    WHILE           reduce using rule 21 (b -> variable_matrix_assign .)
    ELSIF           reduce using rule 21 (b -> variable_matrix_assign .)
    ELSE            reduce using rule 21 (b -> variable_matrix_assign .)
    END_IF          reduce using rule 21 (b -> variable_matrix_assign .)
    END_DO          reduce using rule 21 (b -> variable_matrix_assign .)
    END_FOR         reduce using rule 21 (b -> variable_matrix_assign .)


state 26

    (22) b -> printing_variables .

    EXIT            reduce using rule 22 (b -> printing_variables .)
    ID              reduce using rule 22 (b -> printing_variables .)
    PRINT           reduce using rule 22 (b -> printing_variables .)
    IF              reduce using rule 22 (b -> printing_variables .)
    FOR             reduce using rule 22 (b -> printing_variables .)
    DO              reduce using rule 22 (b -> printing_variables .)
    LOOP            reduce using rule 22 (b -> printing_variables .)
    CALL            reduce using rule 22 (b -> printing_variables .)
    READ            reduce using rule 22 (b -> printing_variables .)
    END             reduce using rule 22 (b -> printing_variables .)
    END_LOOP        reduce using rule 22 (b -> printing_variables .)
    WHILE           reduce using rule 22 (b -> printing_variables .)
    ELSIF           reduce using rule 22 (b -> printing_variables .)
    ELSE            reduce using rule 22 (b -> printing_variables .)
    END_IF          reduce using rule 22 (b -> printing_variables .)
    END_DO          reduce using rule 22 (b -> printing_variables .)
    END_FOR         reduce using rule 22 (b -> printing_variables .)


state 27

    (23) b -> if_expression .

    EXIT            reduce using rule 23 (b -> if_expression .)
    ID              reduce using rule 23 (b -> if_expression .)
    PRINT           reduce using rule 23 (b -> if_expression .)
    IF              reduce using rule 23 (b -> if_expression .)
    FOR             reduce using rule 23 (b -> if_expression .)
    DO              reduce using rule 23 (b -> if_expression .)
    LOOP            reduce using rule 23 (b -> if_expression .)
    CALL            reduce using rule 23 (b -> if_expression .)
    READ            reduce using rule 23 (b -> if_expression .)
    END             reduce using rule 23 (b -> if_expression .)
    END_LOOP        reduce using rule 23 (b -> if_expression .)
    WHILE           reduce using rule 23 (b -> if_expression .)
    ELSIF           reduce using rule 23 (b -> if_expression .)
    ELSE            reduce using rule 23 (b -> if_expression .)
    END_IF          reduce using rule 23 (b -> if_expression .)
    END_DO          reduce using rule 23 (b -> if_expression .)
    END_FOR         reduce using rule 23 (b -> if_expression .)


state 28

    (24) b -> do_loops .

    EXIT            reduce using rule 24 (b -> do_loops .)
    ID              reduce using rule 24 (b -> do_loops .)
    PRINT           reduce using rule 24 (b -> do_loops .)
    IF              reduce using rule 24 (b -> do_loops .)
    FOR             reduce using rule 24 (b -> do_loops .)
    DO              reduce using rule 24 (b -> do_loops .)
    LOOP            reduce using rule 24 (b -> do_loops .)
    CALL            reduce using rule 24 (b -> do_loops .)
    READ            reduce using rule 24 (b -> do_loops .)
    END             reduce using rule 24 (b -> do_loops .)
    END_LOOP        reduce using rule 24 (b -> do_loops .)
    WHILE           reduce using rule 24 (b -> do_loops .)
    ELSIF           reduce using rule 24 (b -> do_loops .)
    ELSE            reduce using rule 24 (b -> do_loops .)
    END_IF          reduce using rule 24 (b -> do_loops .)
    END_DO          reduce using rule 24 (b -> do_loops .)
    END_FOR         reduce using rule 24 (b -> do_loops .)


state 29

    (25) b -> call_subroutine .

    EXIT            reduce using rule 25 (b -> call_subroutine .)
    ID              reduce using rule 25 (b -> call_subroutine .)
    PRINT           reduce using rule 25 (b -> call_subroutine .)
    IF              reduce using rule 25 (b -> call_subroutine .)
    FOR             reduce using rule 25 (b -> call_subroutine .)
    DO              reduce using rule 25 (b -> call_subroutine .)
    LOOP            reduce using rule 25 (b -> call_subroutine .)
    CALL            reduce using rule 25 (b -> call_subroutine .)
    READ            reduce using rule 25 (b -> call_subroutine .)
    END             reduce using rule 25 (b -> call_subroutine .)
    END_LOOP        reduce using rule 25 (b -> call_subroutine .)
    WHILE           reduce using rule 25 (b -> call_subroutine .)
    ELSIF           reduce using rule 25 (b -> call_subroutine .)
    ELSE            reduce using rule 25 (b -> call_subroutine .)
    END_IF          reduce using rule 25 (b -> call_subroutine .)
    END_DO          reduce using rule 25 (b -> call_subroutine .)
    END_FOR         reduce using rule 25 (b -> call_subroutine .)


state 30

    (26) b -> reading_variables .

    EXIT            reduce using rule 26 (b -> reading_variables .)
    ID              reduce using rule 26 (b -> reading_variables .)
    PRINT           reduce using rule 26 (b -> reading_variables .)
    IF              reduce using rule 26 (b -> reading_variables .)
    FOR             reduce using rule 26 (b -> reading_variables .)
    DO              reduce using rule 26 (b -> reading_variables .)
    LOOP            reduce using rule 26 (b -> reading_variables .)
    CALL            reduce using rule 26 (b -> reading_variables .)
    READ            reduce using rule 26 (b -> reading_variables .)
    END             reduce using rule 26 (b -> reading_variables .)
    END_LOOP        reduce using rule 26 (b -> reading_variables .)
    WHILE           reduce using rule 26 (b -> reading_variables .)
    ELSIF           reduce using rule 26 (b -> reading_variables .)
    ELSE            reduce using rule 26 (b -> reading_variables .)
    END_IF          reduce using rule 26 (b -> reading_variables .)
    END_DO          reduce using rule 26 (b -> reading_variables .)
    END_FOR         reduce using rule 26 (b -> reading_variables .)


state 31

    (27) b -> EXIT . paso4DoExit
    (94) paso4DoExit -> . empty
    (95) empty -> .

    EXIT            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    PRINT           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    LOOP            reduce using rule 95 (empty -> .)
    CALL            reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    END_LOOP        reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)
    END_DO          reduce using rule 95 (empty -> .)
    END_FOR         reduce using rule 95 (empty -> .)

    paso4DoExit                    shift and go to state 47
    empty                          shift and go to state 48

state 32

    (47) printing_variables -> PRINT . Output
    (48) Output -> . idOut
    (49) Output -> . LPAREN StringOut RPAREN
    (57) idOut -> . ID

    LPAREN          shift and go to state 51
    ID              shift and go to state 52

    Output                         shift and go to state 49
    idOut                          shift and go to state 50

state 33

    (41) if_expression -> IF . expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> IF . expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (73) expression_logic -> . expression_logic OR g
    (74) expression_logic -> . g
    (75) g -> . g AND ge
    (76) g -> . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    expression_logic               shift and go to state 53
    g                              shift and go to state 54
    ge                             shift and go to state 55

state 34

    (28) do_loops -> FOR . paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (32) paso1FOR -> . ID

    ID              shift and go to state 59

    paso1FOR                       shift and go to state 58

state 35

    (29) do_loops -> DO . constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> DO . paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (87) constante_entero -> . INT
    (89) paso1DO -> . empty
    (95) empty -> .

    INT             shift and go to state 62
    LOOP            reduce using rule 95 (empty -> .)

    constante_entero               shift and go to state 60
    paso1DO                        shift and go to state 61
    empty                          shift and go to state 63

state 36

    (31) do_loops -> LOOP . paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (91) paso1DoExit -> . empty
    (95) empty -> .

    EXIT            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    PRINT           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    LOOP            reduce using rule 95 (empty -> .)
    CALL            reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)

    paso1DoExit                    shift and go to state 64
    empty                          shift and go to state 65

state 37

    (40) call_subroutine -> CALL . ID

    ID              shift and go to state 66


state 38

    (36) reading_variables -> READ . idrepInput
    (37) idrepInput -> . idInput
    (38) idrepInput -> . idInput COMMA idrepInput
    (39) idInput -> . ID

    ID              shift and go to state 69

    idrepInput                     shift and go to state 67
    idInput                        shift and go to state 68

state 39

    (6) var_assign -> type_definition COLONS COLONS var_local . var_dimensiones create_var_table var_assign
    (8) var_dimensiones -> . LARR constante_entero RARR
    (9) var_dimensiones -> . LARR constante_entero COMMA constante_entero RARR
    (10) var_dimensiones -> . empty
    (95) empty -> .

    LARR            shift and go to state 71
    INT_TYPE        reduce using rule 95 (empty -> .)
    FLOAT_TYPE      reduce using rule 95 (empty -> .)
    SUBROUTINE      reduce using rule 95 (empty -> .)
    BEGIN           reduce using rule 95 (empty -> .)

    var_dimensiones                shift and go to state 70
    empty                          shift and go to state 72

state 40

    (12) var_local -> ID . COMMA var_local
    (13) var_local -> ID .

    COMMA           shift and go to state 73
    LARR            reduce using rule 13 (var_local -> ID .)
    INT_TYPE        reduce using rule 13 (var_local -> ID .)
    FLOAT_TYPE      reduce using rule 13 (var_local -> ID .)
    SUBROUTINE      reduce using rule 13 (var_local -> ID .)
    BEGIN           reduce using rule 13 (var_local -> ID .)


state 41

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END . PROGRAM ID

    PROGRAM         shift and go to state 74


state 42

    (18) a -> BEGIN d . END

    END             shift and go to state 75


state 43

    (58) variable_matrix_assign -> ID ASSIGN . expression_arith
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 77
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 44

    (59) variable_matrix_assign -> ID LPAREN . expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> ID LPAREN . expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 84
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 45

    (16) f_local -> SUBROUTINE ID d END . SUBROUTINE ID f_local
    (17) f_local -> SUBROUTINE ID d END . SUBROUTINE ID

    SUBROUTINE      shift and go to state 85


state 46

    (20) d -> b d .

    END             reduce using rule 20 (d -> b d .)
    END_LOOP        reduce using rule 20 (d -> b d .)
    WHILE           reduce using rule 20 (d -> b d .)
    ELSIF           reduce using rule 20 (d -> b d .)
    ELSE            reduce using rule 20 (d -> b d .)
    END_IF          reduce using rule 20 (d -> b d .)
    END_DO          reduce using rule 20 (d -> b d .)
    END_FOR         reduce using rule 20 (d -> b d .)


state 47

    (27) b -> EXIT paso4DoExit .

    EXIT            reduce using rule 27 (b -> EXIT paso4DoExit .)
    ID              reduce using rule 27 (b -> EXIT paso4DoExit .)
    PRINT           reduce using rule 27 (b -> EXIT paso4DoExit .)
    IF              reduce using rule 27 (b -> EXIT paso4DoExit .)
    FOR             reduce using rule 27 (b -> EXIT paso4DoExit .)
    DO              reduce using rule 27 (b -> EXIT paso4DoExit .)
    LOOP            reduce using rule 27 (b -> EXIT paso4DoExit .)
    CALL            reduce using rule 27 (b -> EXIT paso4DoExit .)
    READ            reduce using rule 27 (b -> EXIT paso4DoExit .)
    END             reduce using rule 27 (b -> EXIT paso4DoExit .)
    END_LOOP        reduce using rule 27 (b -> EXIT paso4DoExit .)
    WHILE           reduce using rule 27 (b -> EXIT paso4DoExit .)
    ELSIF           reduce using rule 27 (b -> EXIT paso4DoExit .)
    ELSE            reduce using rule 27 (b -> EXIT paso4DoExit .)
    END_IF          reduce using rule 27 (b -> EXIT paso4DoExit .)
    END_DO          reduce using rule 27 (b -> EXIT paso4DoExit .)
    END_FOR         reduce using rule 27 (b -> EXIT paso4DoExit .)


state 48

    (94) paso4DoExit -> empty .

    EXIT            reduce using rule 94 (paso4DoExit -> empty .)
    ID              reduce using rule 94 (paso4DoExit -> empty .)
    PRINT           reduce using rule 94 (paso4DoExit -> empty .)
    IF              reduce using rule 94 (paso4DoExit -> empty .)
    FOR             reduce using rule 94 (paso4DoExit -> empty .)
    DO              reduce using rule 94 (paso4DoExit -> empty .)
    LOOP            reduce using rule 94 (paso4DoExit -> empty .)
    CALL            reduce using rule 94 (paso4DoExit -> empty .)
    READ            reduce using rule 94 (paso4DoExit -> empty .)
    END             reduce using rule 94 (paso4DoExit -> empty .)
    END_LOOP        reduce using rule 94 (paso4DoExit -> empty .)
    WHILE           reduce using rule 94 (paso4DoExit -> empty .)
    ELSIF           reduce using rule 94 (paso4DoExit -> empty .)
    ELSE            reduce using rule 94 (paso4DoExit -> empty .)
    END_IF          reduce using rule 94 (paso4DoExit -> empty .)
    END_DO          reduce using rule 94 (paso4DoExit -> empty .)
    END_FOR         reduce using rule 94 (paso4DoExit -> empty .)


state 49

    (47) printing_variables -> PRINT Output .

    EXIT            reduce using rule 47 (printing_variables -> PRINT Output .)
    ID              reduce using rule 47 (printing_variables -> PRINT Output .)
    PRINT           reduce using rule 47 (printing_variables -> PRINT Output .)
    IF              reduce using rule 47 (printing_variables -> PRINT Output .)
    FOR             reduce using rule 47 (printing_variables -> PRINT Output .)
    DO              reduce using rule 47 (printing_variables -> PRINT Output .)
    LOOP            reduce using rule 47 (printing_variables -> PRINT Output .)
    CALL            reduce using rule 47 (printing_variables -> PRINT Output .)
    READ            reduce using rule 47 (printing_variables -> PRINT Output .)
    END             reduce using rule 47 (printing_variables -> PRINT Output .)
    END_LOOP        reduce using rule 47 (printing_variables -> PRINT Output .)
    WHILE           reduce using rule 47 (printing_variables -> PRINT Output .)
    ELSIF           reduce using rule 47 (printing_variables -> PRINT Output .)
    ELSE            reduce using rule 47 (printing_variables -> PRINT Output .)
    END_IF          reduce using rule 47 (printing_variables -> PRINT Output .)
    END_DO          reduce using rule 47 (printing_variables -> PRINT Output .)
    END_FOR         reduce using rule 47 (printing_variables -> PRINT Output .)


state 50

    (48) Output -> idOut .

    EXIT            reduce using rule 48 (Output -> idOut .)
    ID              reduce using rule 48 (Output -> idOut .)
    PRINT           reduce using rule 48 (Output -> idOut .)
    IF              reduce using rule 48 (Output -> idOut .)
    FOR             reduce using rule 48 (Output -> idOut .)
    DO              reduce using rule 48 (Output -> idOut .)
    LOOP            reduce using rule 48 (Output -> idOut .)
    CALL            reduce using rule 48 (Output -> idOut .)
    READ            reduce using rule 48 (Output -> idOut .)
    END             reduce using rule 48 (Output -> idOut .)
    END_LOOP        reduce using rule 48 (Output -> idOut .)
    WHILE           reduce using rule 48 (Output -> idOut .)
    ELSIF           reduce using rule 48 (Output -> idOut .)
    ELSE            reduce using rule 48 (Output -> idOut .)
    END_IF          reduce using rule 48 (Output -> idOut .)
    END_DO          reduce using rule 48 (Output -> idOut .)
    END_FOR         reduce using rule 48 (Output -> idOut .)


state 51

    (49) Output -> LPAREN . StringOut RPAREN
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    StringOut                      shift and go to state 86
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89
    constante_flotante             shift and go to state 90

state 52

    (57) idOut -> ID .

    EXIT            reduce using rule 57 (idOut -> ID .)
    ID              reduce using rule 57 (idOut -> ID .)
    PRINT           reduce using rule 57 (idOut -> ID .)
    IF              reduce using rule 57 (idOut -> ID .)
    FOR             reduce using rule 57 (idOut -> ID .)
    DO              reduce using rule 57 (idOut -> ID .)
    LOOP            reduce using rule 57 (idOut -> ID .)
    CALL            reduce using rule 57 (idOut -> ID .)
    READ            reduce using rule 57 (idOut -> ID .)
    END             reduce using rule 57 (idOut -> ID .)
    END_LOOP        reduce using rule 57 (idOut -> ID .)
    WHILE           reduce using rule 57 (idOut -> ID .)
    ELSIF           reduce using rule 57 (idOut -> ID .)
    ELSE            reduce using rule 57 (idOut -> ID .)
    END_IF          reduce using rule 57 (idOut -> ID .)
    END_DO          reduce using rule 57 (idOut -> ID .)
    END_FOR         reduce using rule 57 (idOut -> ID .)


state 53

    (41) if_expression -> IF expression_logic . paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> IF expression_logic . paso1IF THEN if_expression_local paso3IF END_IF
    (73) expression_logic -> expression_logic . OR g
    (84) paso1IF -> . empty
    (95) empty -> .

    OR              shift and go to state 95
    THEN            reduce using rule 95 (empty -> .)

    paso1IF                        shift and go to state 94
    empty                          shift and go to state 96

state 54

    (74) expression_logic -> g .
    (75) g -> g . AND ge

    OR              reduce using rule 74 (expression_logic -> g .)
    THEN            reduce using rule 74 (expression_logic -> g .)
    RPAREN          reduce using rule 74 (expression_logic -> g .)
    END_DO          reduce using rule 74 (expression_logic -> g .)
    AND             shift and go to state 97


state 55

    (76) g -> ge .

    AND             reduce using rule 76 (g -> ge .)
    OR              reduce using rule 76 (g -> ge .)
    THEN            reduce using rule 76 (g -> ge .)
    RPAREN          reduce using rule 76 (g -> ge .)
    END_DO          reduce using rule 76 (g -> ge .)


state 56

    (77) ge -> ID . GT ID
    (78) ge -> ID . LT ID
    (79) ge -> ID . GE ID
    (80) ge -> ID . LE ID
    (81) ge -> ID . NE ID
    (82) ge -> ID . EQUAL ID

    GT              shift and go to state 98
    LT              shift and go to state 99
    GE              shift and go to state 100
    LE              shift and go to state 101
    NE              shift and go to state 102
    EQUAL           shift and go to state 103


state 57

    (83) ge -> LPAREN . expression_logic RPAREN
    (73) expression_logic -> . expression_logic OR g
    (74) expression_logic -> . g
    (75) g -> . g AND ge
    (76) g -> . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    expression_logic               shift and go to state 104
    g                              shift and go to state 54
    ge                             shift and go to state 55

state 58

    (28) do_loops -> FOR paso1FOR . ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR

    ASSIGN          shift and go to state 105


state 59

    (32) paso1FOR -> ID .

    ASSIGN          reduce using rule 32 (paso1FOR -> ID .)


state 60

    (29) do_loops -> DO constante_entero . COMMA constante_entero COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 106


state 61

    (30) do_loops -> DO paso1DO . LOOP d WHILE expression_logic END_DO paso2DO

    LOOP            shift and go to state 107


state 62

    (87) constante_entero -> INT .

    COMMA           reduce using rule 87 (constante_entero -> INT .)
    MULTIPLY        reduce using rule 87 (constante_entero -> INT .)
    DIVIDE          reduce using rule 87 (constante_entero -> INT .)
    PLUS            reduce using rule 87 (constante_entero -> INT .)
    MINUS           reduce using rule 87 (constante_entero -> INT .)
    EXIT            reduce using rule 87 (constante_entero -> INT .)
    ID              reduce using rule 87 (constante_entero -> INT .)
    PRINT           reduce using rule 87 (constante_entero -> INT .)
    IF              reduce using rule 87 (constante_entero -> INT .)
    FOR             reduce using rule 87 (constante_entero -> INT .)
    DO              reduce using rule 87 (constante_entero -> INT .)
    LOOP            reduce using rule 87 (constante_entero -> INT .)
    CALL            reduce using rule 87 (constante_entero -> INT .)
    READ            reduce using rule 87 (constante_entero -> INT .)
    END             reduce using rule 87 (constante_entero -> INT .)
    END_LOOP        reduce using rule 87 (constante_entero -> INT .)
    WHILE           reduce using rule 87 (constante_entero -> INT .)
    ELSIF           reduce using rule 87 (constante_entero -> INT .)
    ELSE            reduce using rule 87 (constante_entero -> INT .)
    END_IF          reduce using rule 87 (constante_entero -> INT .)
    END_DO          reduce using rule 87 (constante_entero -> INT .)
    END_FOR         reduce using rule 87 (constante_entero -> INT .)
    RPAREN          reduce using rule 87 (constante_entero -> INT .)
    COLONS          reduce using rule 87 (constante_entero -> INT .)
    QUESTION        reduce using rule 87 (constante_entero -> INT .)
    INT             reduce using rule 87 (constante_entero -> INT .)
    FLOAT           reduce using rule 87 (constante_entero -> INT .)
    RARR            reduce using rule 87 (constante_entero -> INT .)


state 63

    (89) paso1DO -> empty .

    LOOP            reduce using rule 89 (paso1DO -> empty .)


state 64

    (31) do_loops -> LOOP paso1DoExit . d END_LOOP paso2DoExit paso3DoExit
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    d                              shift and go to state 108
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 65

    (91) paso1DoExit -> empty .

    EXIT            reduce using rule 91 (paso1DoExit -> empty .)
    ID              reduce using rule 91 (paso1DoExit -> empty .)
    PRINT           reduce using rule 91 (paso1DoExit -> empty .)
    IF              reduce using rule 91 (paso1DoExit -> empty .)
    FOR             reduce using rule 91 (paso1DoExit -> empty .)
    DO              reduce using rule 91 (paso1DoExit -> empty .)
    LOOP            reduce using rule 91 (paso1DoExit -> empty .)
    CALL            reduce using rule 91 (paso1DoExit -> empty .)
    READ            reduce using rule 91 (paso1DoExit -> empty .)


state 66

    (40) call_subroutine -> CALL ID .

    EXIT            reduce using rule 40 (call_subroutine -> CALL ID .)
    ID              reduce using rule 40 (call_subroutine -> CALL ID .)
    PRINT           reduce using rule 40 (call_subroutine -> CALL ID .)
    IF              reduce using rule 40 (call_subroutine -> CALL ID .)
    FOR             reduce using rule 40 (call_subroutine -> CALL ID .)
    DO              reduce using rule 40 (call_subroutine -> CALL ID .)
    LOOP            reduce using rule 40 (call_subroutine -> CALL ID .)
    CALL            reduce using rule 40 (call_subroutine -> CALL ID .)
    READ            reduce using rule 40 (call_subroutine -> CALL ID .)
    END             reduce using rule 40 (call_subroutine -> CALL ID .)
    END_LOOP        reduce using rule 40 (call_subroutine -> CALL ID .)
    WHILE           reduce using rule 40 (call_subroutine -> CALL ID .)
    ELSIF           reduce using rule 40 (call_subroutine -> CALL ID .)
    ELSE            reduce using rule 40 (call_subroutine -> CALL ID .)
    END_IF          reduce using rule 40 (call_subroutine -> CALL ID .)
    END_DO          reduce using rule 40 (call_subroutine -> CALL ID .)
    END_FOR         reduce using rule 40 (call_subroutine -> CALL ID .)


state 67

    (36) reading_variables -> READ idrepInput .

    EXIT            reduce using rule 36 (reading_variables -> READ idrepInput .)
    ID              reduce using rule 36 (reading_variables -> READ idrepInput .)
    PRINT           reduce using rule 36 (reading_variables -> READ idrepInput .)
    IF              reduce using rule 36 (reading_variables -> READ idrepInput .)
    FOR             reduce using rule 36 (reading_variables -> READ idrepInput .)
    DO              reduce using rule 36 (reading_variables -> READ idrepInput .)
    LOOP            reduce using rule 36 (reading_variables -> READ idrepInput .)
    CALL            reduce using rule 36 (reading_variables -> READ idrepInput .)
    READ            reduce using rule 36 (reading_variables -> READ idrepInput .)
    END             reduce using rule 36 (reading_variables -> READ idrepInput .)
    END_LOOP        reduce using rule 36 (reading_variables -> READ idrepInput .)
    WHILE           reduce using rule 36 (reading_variables -> READ idrepInput .)
    ELSIF           reduce using rule 36 (reading_variables -> READ idrepInput .)
    ELSE            reduce using rule 36 (reading_variables -> READ idrepInput .)
    END_IF          reduce using rule 36 (reading_variables -> READ idrepInput .)
    END_DO          reduce using rule 36 (reading_variables -> READ idrepInput .)
    END_FOR         reduce using rule 36 (reading_variables -> READ idrepInput .)


state 68

    (37) idrepInput -> idInput .
    (38) idrepInput -> idInput . COMMA idrepInput

    EXIT            reduce using rule 37 (idrepInput -> idInput .)
    ID              reduce using rule 37 (idrepInput -> idInput .)
    PRINT           reduce using rule 37 (idrepInput -> idInput .)
    IF              reduce using rule 37 (idrepInput -> idInput .)
    FOR             reduce using rule 37 (idrepInput -> idInput .)
    DO              reduce using rule 37 (idrepInput -> idInput .)
    LOOP            reduce using rule 37 (idrepInput -> idInput .)
    CALL            reduce using rule 37 (idrepInput -> idInput .)
    READ            reduce using rule 37 (idrepInput -> idInput .)
    END             reduce using rule 37 (idrepInput -> idInput .)
    END_LOOP        reduce using rule 37 (idrepInput -> idInput .)
    WHILE           reduce using rule 37 (idrepInput -> idInput .)
    ELSIF           reduce using rule 37 (idrepInput -> idInput .)
    ELSE            reduce using rule 37 (idrepInput -> idInput .)
    END_IF          reduce using rule 37 (idrepInput -> idInput .)
    END_DO          reduce using rule 37 (idrepInput -> idInput .)
    END_FOR         reduce using rule 37 (idrepInput -> idInput .)
    COMMA           shift and go to state 109


state 69

    (39) idInput -> ID .

    COMMA           reduce using rule 39 (idInput -> ID .)
    EXIT            reduce using rule 39 (idInput -> ID .)
    ID              reduce using rule 39 (idInput -> ID .)
    PRINT           reduce using rule 39 (idInput -> ID .)
    IF              reduce using rule 39 (idInput -> ID .)
    FOR             reduce using rule 39 (idInput -> ID .)
    DO              reduce using rule 39 (idInput -> ID .)
    LOOP            reduce using rule 39 (idInput -> ID .)
    CALL            reduce using rule 39 (idInput -> ID .)
    READ            reduce using rule 39 (idInput -> ID .)
    END             reduce using rule 39 (idInput -> ID .)
    END_LOOP        reduce using rule 39 (idInput -> ID .)
    WHILE           reduce using rule 39 (idInput -> ID .)
    ELSIF           reduce using rule 39 (idInput -> ID .)
    ELSE            reduce using rule 39 (idInput -> ID .)
    END_IF          reduce using rule 39 (idInput -> ID .)
    END_DO          reduce using rule 39 (idInput -> ID .)
    END_FOR         reduce using rule 39 (idInput -> ID .)


state 70

    (6) var_assign -> type_definition COLONS COLONS var_local var_dimensiones . create_var_table var_assign
    (11) create_var_table -> . empty
    (95) empty -> .

    INT_TYPE        reduce using rule 95 (empty -> .)
    FLOAT_TYPE      reduce using rule 95 (empty -> .)
    SUBROUTINE      reduce using rule 95 (empty -> .)
    BEGIN           reduce using rule 95 (empty -> .)

    create_var_table               shift and go to state 110
    empty                          shift and go to state 111

state 71

    (8) var_dimensiones -> LARR . constante_entero RARR
    (9) var_dimensiones -> LARR . constante_entero COMMA constante_entero RARR
    (87) constante_entero -> . INT

    INT             shift and go to state 62

    constante_entero               shift and go to state 112

state 72

    (10) var_dimensiones -> empty .

    INT_TYPE        reduce using rule 10 (var_dimensiones -> empty .)
    FLOAT_TYPE      reduce using rule 10 (var_dimensiones -> empty .)
    SUBROUTINE      reduce using rule 10 (var_dimensiones -> empty .)
    BEGIN           reduce using rule 10 (var_dimensiones -> empty .)


state 73

    (12) var_local -> ID COMMA . var_local
    (12) var_local -> . ID COMMA var_local
    (13) var_local -> . ID

    ID              shift and go to state 40

    var_local                      shift and go to state 113

state 74

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM . ID

    ID              shift and go to state 114


state 75

    (18) a -> BEGIN d END .

    END             reduce using rule 18 (a -> BEGIN d END .)


state 76

    (67) te -> ID .
    (70) te -> ID . LPAREN expression_arith RPAREN
    (71) te -> ID . LPAREN expression_arith COMMA expression_arith RPAREN

    MULTIPLY        reduce using rule 67 (te -> ID .)
    DIVIDE          reduce using rule 67 (te -> ID .)
    PLUS            reduce using rule 67 (te -> ID .)
    MINUS           reduce using rule 67 (te -> ID .)
    EXIT            reduce using rule 67 (te -> ID .)
    ID              reduce using rule 67 (te -> ID .)
    PRINT           reduce using rule 67 (te -> ID .)
    IF              reduce using rule 67 (te -> ID .)
    FOR             reduce using rule 67 (te -> ID .)
    DO              reduce using rule 67 (te -> ID .)
    LOOP            reduce using rule 67 (te -> ID .)
    CALL            reduce using rule 67 (te -> ID .)
    READ            reduce using rule 67 (te -> ID .)
    END             reduce using rule 67 (te -> ID .)
    END_LOOP        reduce using rule 67 (te -> ID .)
    WHILE           reduce using rule 67 (te -> ID .)
    ELSIF           reduce using rule 67 (te -> ID .)
    ELSE            reduce using rule 67 (te -> ID .)
    END_IF          reduce using rule 67 (te -> ID .)
    END_DO          reduce using rule 67 (te -> ID .)
    END_FOR         reduce using rule 67 (te -> ID .)
    RPAREN          reduce using rule 67 (te -> ID .)
    COMMA           reduce using rule 67 (te -> ID .)
    LPAREN          shift and go to state 115


state 77

    (58) variable_matrix_assign -> ID ASSIGN expression_arith .
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ID              reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    PRINT           reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    IF              reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    FOR             reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    DO              reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    LOOP            reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    CALL            reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    READ            reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END             reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_LOOP        reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    WHILE           reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ELSIF           reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    ELSE            reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_IF          reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_DO          reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    END_FOR         reduce using rule 58 (variable_matrix_assign -> ID ASSIGN expression_arith .)
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 78

    (63) expression_arith -> c .
    (64) c -> c . MULTIPLY te
    (65) c -> c . DIVIDE te

    PLUS            reduce using rule 63 (expression_arith -> c .)
    MINUS           reduce using rule 63 (expression_arith -> c .)
    EXIT            reduce using rule 63 (expression_arith -> c .)
    ID              reduce using rule 63 (expression_arith -> c .)
    PRINT           reduce using rule 63 (expression_arith -> c .)
    IF              reduce using rule 63 (expression_arith -> c .)
    FOR             reduce using rule 63 (expression_arith -> c .)
    DO              reduce using rule 63 (expression_arith -> c .)
    LOOP            reduce using rule 63 (expression_arith -> c .)
    CALL            reduce using rule 63 (expression_arith -> c .)
    READ            reduce using rule 63 (expression_arith -> c .)
    END             reduce using rule 63 (expression_arith -> c .)
    END_LOOP        reduce using rule 63 (expression_arith -> c .)
    WHILE           reduce using rule 63 (expression_arith -> c .)
    ELSIF           reduce using rule 63 (expression_arith -> c .)
    ELSE            reduce using rule 63 (expression_arith -> c .)
    END_IF          reduce using rule 63 (expression_arith -> c .)
    END_DO          reduce using rule 63 (expression_arith -> c .)
    END_FOR         reduce using rule 63 (expression_arith -> c .)
    RPAREN          reduce using rule 63 (expression_arith -> c .)
    COMMA           reduce using rule 63 (expression_arith -> c .)
    MULTIPLY        shift and go to state 118
    DIVIDE          shift and go to state 119


state 79

    (66) c -> te .

    MULTIPLY        reduce using rule 66 (c -> te .)
    DIVIDE          reduce using rule 66 (c -> te .)
    PLUS            reduce using rule 66 (c -> te .)
    MINUS           reduce using rule 66 (c -> te .)
    EXIT            reduce using rule 66 (c -> te .)
    ID              reduce using rule 66 (c -> te .)
    PRINT           reduce using rule 66 (c -> te .)
    IF              reduce using rule 66 (c -> te .)
    FOR             reduce using rule 66 (c -> te .)
    DO              reduce using rule 66 (c -> te .)
    LOOP            reduce using rule 66 (c -> te .)
    CALL            reduce using rule 66 (c -> te .)
    READ            reduce using rule 66 (c -> te .)
    END             reduce using rule 66 (c -> te .)
    END_LOOP        reduce using rule 66 (c -> te .)
    WHILE           reduce using rule 66 (c -> te .)
    ELSIF           reduce using rule 66 (c -> te .)
    ELSE            reduce using rule 66 (c -> te .)
    END_IF          reduce using rule 66 (c -> te .)
    END_DO          reduce using rule 66 (c -> te .)
    END_FOR         reduce using rule 66 (c -> te .)
    RPAREN          reduce using rule 66 (c -> te .)
    COMMA           reduce using rule 66 (c -> te .)


state 80

    (68) te -> constante_entero .

    MULTIPLY        reduce using rule 68 (te -> constante_entero .)
    DIVIDE          reduce using rule 68 (te -> constante_entero .)
    PLUS            reduce using rule 68 (te -> constante_entero .)
    MINUS           reduce using rule 68 (te -> constante_entero .)
    EXIT            reduce using rule 68 (te -> constante_entero .)
    ID              reduce using rule 68 (te -> constante_entero .)
    PRINT           reduce using rule 68 (te -> constante_entero .)
    IF              reduce using rule 68 (te -> constante_entero .)
    FOR             reduce using rule 68 (te -> constante_entero .)
    DO              reduce using rule 68 (te -> constante_entero .)
    LOOP            reduce using rule 68 (te -> constante_entero .)
    CALL            reduce using rule 68 (te -> constante_entero .)
    READ            reduce using rule 68 (te -> constante_entero .)
    END             reduce using rule 68 (te -> constante_entero .)
    END_LOOP        reduce using rule 68 (te -> constante_entero .)
    WHILE           reduce using rule 68 (te -> constante_entero .)
    ELSIF           reduce using rule 68 (te -> constante_entero .)
    ELSE            reduce using rule 68 (te -> constante_entero .)
    END_IF          reduce using rule 68 (te -> constante_entero .)
    END_DO          reduce using rule 68 (te -> constante_entero .)
    END_FOR         reduce using rule 68 (te -> constante_entero .)
    RPAREN          reduce using rule 68 (te -> constante_entero .)
    COMMA           reduce using rule 68 (te -> constante_entero .)


state 81

    (69) te -> constante_flotante .

    MULTIPLY        reduce using rule 69 (te -> constante_flotante .)
    DIVIDE          reduce using rule 69 (te -> constante_flotante .)
    PLUS            reduce using rule 69 (te -> constante_flotante .)
    MINUS           reduce using rule 69 (te -> constante_flotante .)
    EXIT            reduce using rule 69 (te -> constante_flotante .)
    ID              reduce using rule 69 (te -> constante_flotante .)
    PRINT           reduce using rule 69 (te -> constante_flotante .)
    IF              reduce using rule 69 (te -> constante_flotante .)
    FOR             reduce using rule 69 (te -> constante_flotante .)
    DO              reduce using rule 69 (te -> constante_flotante .)
    LOOP            reduce using rule 69 (te -> constante_flotante .)
    CALL            reduce using rule 69 (te -> constante_flotante .)
    READ            reduce using rule 69 (te -> constante_flotante .)
    END             reduce using rule 69 (te -> constante_flotante .)
    END_LOOP        reduce using rule 69 (te -> constante_flotante .)
    WHILE           reduce using rule 69 (te -> constante_flotante .)
    ELSIF           reduce using rule 69 (te -> constante_flotante .)
    ELSE            reduce using rule 69 (te -> constante_flotante .)
    END_IF          reduce using rule 69 (te -> constante_flotante .)
    END_DO          reduce using rule 69 (te -> constante_flotante .)
    END_FOR         reduce using rule 69 (te -> constante_flotante .)
    RPAREN          reduce using rule 69 (te -> constante_flotante .)
    COMMA           reduce using rule 69 (te -> constante_flotante .)


state 82

    (72) te -> LPAREN . expression_arith RPAREN
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 120
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 83

    (88) constante_flotante -> FLOAT .

    MULTIPLY        reduce using rule 88 (constante_flotante -> FLOAT .)
    DIVIDE          reduce using rule 88 (constante_flotante -> FLOAT .)
    PLUS            reduce using rule 88 (constante_flotante -> FLOAT .)
    MINUS           reduce using rule 88 (constante_flotante -> FLOAT .)
    EXIT            reduce using rule 88 (constante_flotante -> FLOAT .)
    ID              reduce using rule 88 (constante_flotante -> FLOAT .)
    PRINT           reduce using rule 88 (constante_flotante -> FLOAT .)
    IF              reduce using rule 88 (constante_flotante -> FLOAT .)
    FOR             reduce using rule 88 (constante_flotante -> FLOAT .)
    DO              reduce using rule 88 (constante_flotante -> FLOAT .)
    LOOP            reduce using rule 88 (constante_flotante -> FLOAT .)
    CALL            reduce using rule 88 (constante_flotante -> FLOAT .)
    READ            reduce using rule 88 (constante_flotante -> FLOAT .)
    END             reduce using rule 88 (constante_flotante -> FLOAT .)
    END_LOOP        reduce using rule 88 (constante_flotante -> FLOAT .)
    WHILE           reduce using rule 88 (constante_flotante -> FLOAT .)
    ELSIF           reduce using rule 88 (constante_flotante -> FLOAT .)
    ELSE            reduce using rule 88 (constante_flotante -> FLOAT .)
    END_IF          reduce using rule 88 (constante_flotante -> FLOAT .)
    END_DO          reduce using rule 88 (constante_flotante -> FLOAT .)
    END_FOR         reduce using rule 88 (constante_flotante -> FLOAT .)
    RPAREN          reduce using rule 88 (constante_flotante -> FLOAT .)
    COMMA           reduce using rule 88 (constante_flotante -> FLOAT .)
    COLONS          reduce using rule 88 (constante_flotante -> FLOAT .)
    QUESTION        reduce using rule 88 (constante_flotante -> FLOAT .)
    INT             reduce using rule 88 (constante_flotante -> FLOAT .)
    FLOAT           reduce using rule 88 (constante_flotante -> FLOAT .)


state 84

    (59) variable_matrix_assign -> ID LPAREN expression_arith . RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> ID LPAREN expression_arith . COMMA expression_arith RPAREN ASSIGN expression_arith
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 121
    COMMA           shift and go to state 122
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 85

    (16) f_local -> SUBROUTINE ID d END SUBROUTINE . ID f_local
    (17) f_local -> SUBROUTINE ID d END SUBROUTINE . ID

    ID              shift and go to state 123


state 86

    (49) Output -> LPAREN StringOut . RPAREN

    RPAREN          shift and go to state 124


state 87

    (50) StringOut -> empty .

    RPAREN          reduce using rule 50 (StringOut -> empty .)


state 88

    (51) StringOut -> ID . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    StringOut                      shift and go to state 125
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89
    constante_flotante             shift and go to state 90

state 89

    (52) StringOut -> constante_entero . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    constante_entero               shift and go to state 89
    StringOut                      shift and go to state 126
    empty                          shift and go to state 87
    constante_flotante             shift and go to state 90

state 90

    (53) StringOut -> constante_flotante . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    constante_flotante             shift and go to state 90
    StringOut                      shift and go to state 127
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89

state 91

    (54) StringOut -> COLONS . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    StringOut                      shift and go to state 128
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89
    constante_flotante             shift and go to state 90

state 92

    (55) StringOut -> COMMA . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    StringOut                      shift and go to state 129
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89
    constante_flotante             shift and go to state 90

state 93

    (56) StringOut -> QUESTION . StringOut
    (50) StringOut -> . empty
    (51) StringOut -> . ID StringOut
    (52) StringOut -> . constante_entero StringOut
    (53) StringOut -> . constante_flotante StringOut
    (54) StringOut -> . COLONS StringOut
    (55) StringOut -> . COMMA StringOut
    (56) StringOut -> . QUESTION StringOut
    (95) empty -> .
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 88
    COLONS          shift and go to state 91
    COMMA           shift and go to state 92
    QUESTION        shift and go to state 93
    RPAREN          reduce using rule 95 (empty -> .)
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    StringOut                      shift and go to state 130
    empty                          shift and go to state 87
    constante_entero               shift and go to state 89
    constante_flotante             shift and go to state 90

state 94

    (41) if_expression -> IF expression_logic paso1IF . THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> IF expression_logic paso1IF . THEN if_expression_local paso3IF END_IF

    THEN            shift and go to state 131


state 95

    (73) expression_logic -> expression_logic OR . g
    (75) g -> . g AND ge
    (76) g -> . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    g                              shift and go to state 132
    ge                             shift and go to state 55

state 96

    (84) paso1IF -> empty .

    THEN            reduce using rule 84 (paso1IF -> empty .)


state 97

    (75) g -> g AND . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    ge                             shift and go to state 133

state 98

    (77) ge -> ID GT . ID

    ID              shift and go to state 134


state 99

    (78) ge -> ID LT . ID

    ID              shift and go to state 135


state 100

    (79) ge -> ID GE . ID

    ID              shift and go to state 136


state 101

    (80) ge -> ID LE . ID

    ID              shift and go to state 137


state 102

    (81) ge -> ID NE . ID

    ID              shift and go to state 138


state 103

    (82) ge -> ID EQUAL . ID

    ID              shift and go to state 139


state 104

    (83) ge -> LPAREN expression_logic . RPAREN
    (73) expression_logic -> expression_logic . OR g

    RPAREN          shift and go to state 140
    OR              shift and go to state 95


state 105

    (28) do_loops -> FOR paso1FOR ASSIGN . expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 141
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 106

    (29) do_loops -> DO constante_entero COMMA . constante_entero COMMA variable_matrix_assign d END_DO
    (87) constante_entero -> . INT

    INT             shift and go to state 62

    constante_entero               shift and go to state 142

state 107

    (30) do_loops -> DO paso1DO LOOP . d WHILE expression_logic END_DO paso2DO
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    d                              shift and go to state 143
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 108

    (31) do_loops -> LOOP paso1DoExit d . END_LOOP paso2DoExit paso3DoExit

    END_LOOP        shift and go to state 144


state 109

    (38) idrepInput -> idInput COMMA . idrepInput
    (37) idrepInput -> . idInput
    (38) idrepInput -> . idInput COMMA idrepInput
    (39) idInput -> . ID

    ID              shift and go to state 69

    idInput                        shift and go to state 68
    idrepInput                     shift and go to state 145

state 110

    (6) var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table . var_assign
    (6) var_assign -> . type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign
    (7) var_assign -> . empty
    (4) type_definition -> . INT_TYPE
    (5) type_definition -> . FLOAT_TYPE
    (95) empty -> .

    INT_TYPE        shift and go to state 9
    FLOAT_TYPE      shift and go to state 10
    SUBROUTINE      reduce using rule 95 (empty -> .)
    BEGIN           reduce using rule 95 (empty -> .)

    type_definition                shift and go to state 7
    var_assign                     shift and go to state 146
    empty                          shift and go to state 8

state 111

    (11) create_var_table -> empty .

    INT_TYPE        reduce using rule 11 (create_var_table -> empty .)
    FLOAT_TYPE      reduce using rule 11 (create_var_table -> empty .)
    SUBROUTINE      reduce using rule 11 (create_var_table -> empty .)
    BEGIN           reduce using rule 11 (create_var_table -> empty .)


state 112

    (8) var_dimensiones -> LARR constante_entero . RARR
    (9) var_dimensiones -> LARR constante_entero . COMMA constante_entero RARR

    RARR            shift and go to state 147
    COMMA           shift and go to state 148


state 113

    (12) var_local -> ID COMMA var_local .

    LARR            reduce using rule 12 (var_local -> ID COMMA var_local .)
    INT_TYPE        reduce using rule 12 (var_local -> ID COMMA var_local .)
    FLOAT_TYPE      reduce using rule 12 (var_local -> ID COMMA var_local .)
    SUBROUTINE      reduce using rule 12 (var_local -> ID COMMA var_local .)
    BEGIN           reduce using rule 12 (var_local -> ID COMMA var_local .)


state 114

    (1) program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID .

    $end            reduce using rule 1 (program -> PROGRAM ID primerCuad var_assign subrutinas rellenaCuad a END PROGRAM ID .)


state 115

    (70) te -> ID LPAREN . expression_arith RPAREN
    (71) te -> ID LPAREN . expression_arith COMMA expression_arith RPAREN
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 149
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 116

    (61) expression_arith -> expression_arith PLUS . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    c                              shift and go to state 150
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 117

    (62) expression_arith -> expression_arith MINUS . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    c                              shift and go to state 151
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 118

    (64) c -> c MULTIPLY . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    te                             shift and go to state 152
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 119

    (65) c -> c DIVIDE . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    te                             shift and go to state 153
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 120

    (72) te -> LPAREN expression_arith . RPAREN
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 154
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 121

    (59) variable_matrix_assign -> ID LPAREN expression_arith RPAREN . ASSIGN expression_arith

    ASSIGN          shift and go to state 155


state 122

    (60) variable_matrix_assign -> ID LPAREN expression_arith COMMA . expression_arith RPAREN ASSIGN expression_arith
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 156
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 123

    (16) f_local -> SUBROUTINE ID d END SUBROUTINE ID . f_local
    (17) f_local -> SUBROUTINE ID d END SUBROUTINE ID .
    (16) f_local -> . SUBROUTINE ID d END SUBROUTINE ID f_local
    (17) f_local -> . SUBROUTINE ID d END SUBROUTINE ID

    BEGIN           reduce using rule 17 (f_local -> SUBROUTINE ID d END SUBROUTINE ID .)
    SUBROUTINE      shift and go to state 14

    f_local                        shift and go to state 157

state 124

    (49) Output -> LPAREN StringOut RPAREN .

    EXIT            reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    ID              reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    PRINT           reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    IF              reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    FOR             reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    DO              reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    LOOP            reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    CALL            reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    READ            reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    END             reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    END_LOOP        reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    WHILE           reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    ELSIF           reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    ELSE            reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    END_IF          reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    END_DO          reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)
    END_FOR         reduce using rule 49 (Output -> LPAREN StringOut RPAREN .)


state 125

    (51) StringOut -> ID StringOut .

    RPAREN          reduce using rule 51 (StringOut -> ID StringOut .)


state 126

    (52) StringOut -> constante_entero StringOut .

    RPAREN          reduce using rule 52 (StringOut -> constante_entero StringOut .)


state 127

    (53) StringOut -> constante_flotante StringOut .

    RPAREN          reduce using rule 53 (StringOut -> constante_flotante StringOut .)


state 128

    (54) StringOut -> COLONS StringOut .

    RPAREN          reduce using rule 54 (StringOut -> COLONS StringOut .)


state 129

    (55) StringOut -> COMMA StringOut .

    RPAREN          reduce using rule 55 (StringOut -> COMMA StringOut .)


state 130

    (56) StringOut -> QUESTION StringOut .

    RPAREN          reduce using rule 56 (StringOut -> QUESTION StringOut .)


state 131

    (41) if_expression -> IF expression_logic paso1IF THEN . if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> IF expression_logic paso1IF THEN . if_expression_local paso3IF END_IF
    (43) if_expression_local -> . d
    (44) if_expression_local -> . empty
    (19) d -> . b
    (20) d -> . b d
    (95) empty -> .
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)
    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    if_expression_local            shift and go to state 158
    d                              shift and go to state 159
    empty                          shift and go to state 160
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 132

    (73) expression_logic -> expression_logic OR g .
    (75) g -> g . AND ge

    OR              reduce using rule 73 (expression_logic -> expression_logic OR g .)
    THEN            reduce using rule 73 (expression_logic -> expression_logic OR g .)
    RPAREN          reduce using rule 73 (expression_logic -> expression_logic OR g .)
    END_DO          reduce using rule 73 (expression_logic -> expression_logic OR g .)
    AND             shift and go to state 97


state 133

    (75) g -> g AND ge .

    AND             reduce using rule 75 (g -> g AND ge .)
    OR              reduce using rule 75 (g -> g AND ge .)
    THEN            reduce using rule 75 (g -> g AND ge .)
    RPAREN          reduce using rule 75 (g -> g AND ge .)
    END_DO          reduce using rule 75 (g -> g AND ge .)


state 134

    (77) ge -> ID GT ID .

    AND             reduce using rule 77 (ge -> ID GT ID .)
    OR              reduce using rule 77 (ge -> ID GT ID .)
    THEN            reduce using rule 77 (ge -> ID GT ID .)
    RPAREN          reduce using rule 77 (ge -> ID GT ID .)
    END_DO          reduce using rule 77 (ge -> ID GT ID .)


state 135

    (78) ge -> ID LT ID .

    AND             reduce using rule 78 (ge -> ID LT ID .)
    OR              reduce using rule 78 (ge -> ID LT ID .)
    THEN            reduce using rule 78 (ge -> ID LT ID .)
    RPAREN          reduce using rule 78 (ge -> ID LT ID .)
    END_DO          reduce using rule 78 (ge -> ID LT ID .)


state 136

    (79) ge -> ID GE ID .

    AND             reduce using rule 79 (ge -> ID GE ID .)
    OR              reduce using rule 79 (ge -> ID GE ID .)
    THEN            reduce using rule 79 (ge -> ID GE ID .)
    RPAREN          reduce using rule 79 (ge -> ID GE ID .)
    END_DO          reduce using rule 79 (ge -> ID GE ID .)


state 137

    (80) ge -> ID LE ID .

    AND             reduce using rule 80 (ge -> ID LE ID .)
    OR              reduce using rule 80 (ge -> ID LE ID .)
    THEN            reduce using rule 80 (ge -> ID LE ID .)
    RPAREN          reduce using rule 80 (ge -> ID LE ID .)
    END_DO          reduce using rule 80 (ge -> ID LE ID .)


state 138

    (81) ge -> ID NE ID .

    AND             reduce using rule 81 (ge -> ID NE ID .)
    OR              reduce using rule 81 (ge -> ID NE ID .)
    THEN            reduce using rule 81 (ge -> ID NE ID .)
    RPAREN          reduce using rule 81 (ge -> ID NE ID .)
    END_DO          reduce using rule 81 (ge -> ID NE ID .)


state 139

    (82) ge -> ID EQUAL ID .

    AND             reduce using rule 82 (ge -> ID EQUAL ID .)
    OR              reduce using rule 82 (ge -> ID EQUAL ID .)
    THEN            reduce using rule 82 (ge -> ID EQUAL ID .)
    RPAREN          reduce using rule 82 (ge -> ID EQUAL ID .)
    END_DO          reduce using rule 82 (ge -> ID EQUAL ID .)


state 140

    (83) ge -> LPAREN expression_logic RPAREN .

    AND             reduce using rule 83 (ge -> LPAREN expression_logic RPAREN .)
    OR              reduce using rule 83 (ge -> LPAREN expression_logic RPAREN .)
    THEN            reduce using rule 83 (ge -> LPAREN expression_logic RPAREN .)
    RPAREN          reduce using rule 83 (ge -> LPAREN expression_logic RPAREN .)
    END_DO          reduce using rule 83 (ge -> LPAREN expression_logic RPAREN .)


state 141

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith . paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c
    (33) paso2FOR -> . empty
    (95) empty -> .

    PLUS            shift and go to state 116
    MINUS           shift and go to state 117
    COMMA           reduce using rule 95 (empty -> .)

    paso2FOR                       shift and go to state 161
    empty                          shift and go to state 162

state 142

    (29) do_loops -> DO constante_entero COMMA constante_entero . COMMA variable_matrix_assign d END_DO

    COMMA           shift and go to state 163


state 143

    (30) do_loops -> DO paso1DO LOOP d . WHILE expression_logic END_DO paso2DO

    WHILE           shift and go to state 164


state 144

    (31) do_loops -> LOOP paso1DoExit d END_LOOP . paso2DoExit paso3DoExit
    (92) paso2DoExit -> . empty
    (95) empty -> .

    EXIT            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    PRINT           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    LOOP            reduce using rule 95 (empty -> .)
    CALL            reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    END_LOOP        reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)
    END_DO          reduce using rule 95 (empty -> .)
    END_FOR         reduce using rule 95 (empty -> .)

    paso2DoExit                    shift and go to state 165
    empty                          shift and go to state 166

state 145

    (38) idrepInput -> idInput COMMA idrepInput .

    EXIT            reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    ID              reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    PRINT           reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    IF              reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    FOR             reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    DO              reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    LOOP            reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    CALL            reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    READ            reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    END             reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    END_LOOP        reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    WHILE           reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    ELSIF           reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    ELSE            reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    END_IF          reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    END_DO          reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)
    END_FOR         reduce using rule 38 (idrepInput -> idInput COMMA idrepInput .)


state 146

    (6) var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .

    SUBROUTINE      reduce using rule 6 (var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .)
    BEGIN           reduce using rule 6 (var_assign -> type_definition COLONS COLONS var_local var_dimensiones create_var_table var_assign .)


state 147

    (8) var_dimensiones -> LARR constante_entero RARR .

    INT_TYPE        reduce using rule 8 (var_dimensiones -> LARR constante_entero RARR .)
    FLOAT_TYPE      reduce using rule 8 (var_dimensiones -> LARR constante_entero RARR .)
    SUBROUTINE      reduce using rule 8 (var_dimensiones -> LARR constante_entero RARR .)
    BEGIN           reduce using rule 8 (var_dimensiones -> LARR constante_entero RARR .)


state 148

    (9) var_dimensiones -> LARR constante_entero COMMA . constante_entero RARR
    (87) constante_entero -> . INT

    INT             shift and go to state 62

    constante_entero               shift and go to state 167

state 149

    (70) te -> ID LPAREN expression_arith . RPAREN
    (71) te -> ID LPAREN expression_arith . COMMA expression_arith RPAREN
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 168
    COMMA           shift and go to state 169
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 150

    (61) expression_arith -> expression_arith PLUS c .
    (64) c -> c . MULTIPLY te
    (65) c -> c . DIVIDE te

    PLUS            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    MINUS           reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    EXIT            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    ID              reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    PRINT           reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    IF              reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    FOR             reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    DO              reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    LOOP            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    CALL            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    READ            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    END             reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    END_LOOP        reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    WHILE           reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    ELSIF           reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    ELSE            reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    END_IF          reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    END_DO          reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    END_FOR         reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    RPAREN          reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    COMMA           reduce using rule 61 (expression_arith -> expression_arith PLUS c .)
    MULTIPLY        shift and go to state 118
    DIVIDE          shift and go to state 119


state 151

    (62) expression_arith -> expression_arith MINUS c .
    (64) c -> c . MULTIPLY te
    (65) c -> c . DIVIDE te

    PLUS            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    MINUS           reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    EXIT            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    ID              reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    PRINT           reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    IF              reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    FOR             reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    DO              reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    LOOP            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    CALL            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    READ            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    END             reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    END_LOOP        reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    WHILE           reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    ELSIF           reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    ELSE            reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    END_IF          reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    END_DO          reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    END_FOR         reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    RPAREN          reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    COMMA           reduce using rule 62 (expression_arith -> expression_arith MINUS c .)
    MULTIPLY        shift and go to state 118
    DIVIDE          shift and go to state 119


state 152

    (64) c -> c MULTIPLY te .

    MULTIPLY        reduce using rule 64 (c -> c MULTIPLY te .)
    DIVIDE          reduce using rule 64 (c -> c MULTIPLY te .)
    PLUS            reduce using rule 64 (c -> c MULTIPLY te .)
    MINUS           reduce using rule 64 (c -> c MULTIPLY te .)
    EXIT            reduce using rule 64 (c -> c MULTIPLY te .)
    ID              reduce using rule 64 (c -> c MULTIPLY te .)
    PRINT           reduce using rule 64 (c -> c MULTIPLY te .)
    IF              reduce using rule 64 (c -> c MULTIPLY te .)
    FOR             reduce using rule 64 (c -> c MULTIPLY te .)
    DO              reduce using rule 64 (c -> c MULTIPLY te .)
    LOOP            reduce using rule 64 (c -> c MULTIPLY te .)
    CALL            reduce using rule 64 (c -> c MULTIPLY te .)
    READ            reduce using rule 64 (c -> c MULTIPLY te .)
    END             reduce using rule 64 (c -> c MULTIPLY te .)
    END_LOOP        reduce using rule 64 (c -> c MULTIPLY te .)
    WHILE           reduce using rule 64 (c -> c MULTIPLY te .)
    ELSIF           reduce using rule 64 (c -> c MULTIPLY te .)
    ELSE            reduce using rule 64 (c -> c MULTIPLY te .)
    END_IF          reduce using rule 64 (c -> c MULTIPLY te .)
    END_DO          reduce using rule 64 (c -> c MULTIPLY te .)
    END_FOR         reduce using rule 64 (c -> c MULTIPLY te .)
    RPAREN          reduce using rule 64 (c -> c MULTIPLY te .)
    COMMA           reduce using rule 64 (c -> c MULTIPLY te .)


state 153

    (65) c -> c DIVIDE te .

    MULTIPLY        reduce using rule 65 (c -> c DIVIDE te .)
    DIVIDE          reduce using rule 65 (c -> c DIVIDE te .)
    PLUS            reduce using rule 65 (c -> c DIVIDE te .)
    MINUS           reduce using rule 65 (c -> c DIVIDE te .)
    EXIT            reduce using rule 65 (c -> c DIVIDE te .)
    ID              reduce using rule 65 (c -> c DIVIDE te .)
    PRINT           reduce using rule 65 (c -> c DIVIDE te .)
    IF              reduce using rule 65 (c -> c DIVIDE te .)
    FOR             reduce using rule 65 (c -> c DIVIDE te .)
    DO              reduce using rule 65 (c -> c DIVIDE te .)
    LOOP            reduce using rule 65 (c -> c DIVIDE te .)
    CALL            reduce using rule 65 (c -> c DIVIDE te .)
    READ            reduce using rule 65 (c -> c DIVIDE te .)
    END             reduce using rule 65 (c -> c DIVIDE te .)
    END_LOOP        reduce using rule 65 (c -> c DIVIDE te .)
    WHILE           reduce using rule 65 (c -> c DIVIDE te .)
    ELSIF           reduce using rule 65 (c -> c DIVIDE te .)
    ELSE            reduce using rule 65 (c -> c DIVIDE te .)
    END_IF          reduce using rule 65 (c -> c DIVIDE te .)
    END_DO          reduce using rule 65 (c -> c DIVIDE te .)
    END_FOR         reduce using rule 65 (c -> c DIVIDE te .)
    RPAREN          reduce using rule 65 (c -> c DIVIDE te .)
    COMMA           reduce using rule 65 (c -> c DIVIDE te .)


state 154

    (72) te -> LPAREN expression_arith RPAREN .

    MULTIPLY        reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    DIVIDE          reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    PLUS            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    MINUS           reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    EXIT            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    ID              reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    PRINT           reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    IF              reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    FOR             reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    DO              reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    LOOP            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    CALL            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    READ            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    END             reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    END_LOOP        reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    WHILE           reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    ELSIF           reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    ELSE            reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    END_IF          reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    END_DO          reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    END_FOR         reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    RPAREN          reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)
    COMMA           reduce using rule 72 (te -> LPAREN expression_arith RPAREN .)


state 155

    (59) variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN . expression_arith
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 170
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 156

    (60) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith . RPAREN ASSIGN expression_arith
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 171
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 157

    (16) f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local .

    BEGIN           reduce using rule 16 (f_local -> SUBROUTINE ID d END SUBROUTINE ID f_local .)


state 158

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local . if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> IF expression_logic paso1IF THEN if_expression_local . paso3IF END_IF
    (45) if_expression_local2 -> . ELSIF expression_logic THEN if_expression_local if_expression_local2
    (46) if_expression_local2 -> . empty
    (86) paso3IF -> . empty
    (95) empty -> .

    ELSIF           shift and go to state 174
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)

    if_expression_local2           shift and go to state 172
    paso3IF                        shift and go to state 173
    empty                          shift and go to state 175

state 159

    (43) if_expression_local -> d .

    ELSIF           reduce using rule 43 (if_expression_local -> d .)
    ELSE            reduce using rule 43 (if_expression_local -> d .)
    END_IF          reduce using rule 43 (if_expression_local -> d .)


state 160

    (44) if_expression_local -> empty .

    ELSIF           reduce using rule 44 (if_expression_local -> empty .)
    ELSE            reduce using rule 44 (if_expression_local -> empty .)
    END_IF          reduce using rule 44 (if_expression_local -> empty .)


state 161

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR . COMMA expression_arith paso3FOR DO d paso4FOR END_FOR

    COMMA           shift and go to state 176


state 162

    (33) paso2FOR -> empty .

    COMMA           reduce using rule 33 (paso2FOR -> empty .)


state 163

    (29) do_loops -> DO constante_entero COMMA constante_entero COMMA . variable_matrix_assign d END_DO
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith

    ID              shift and go to state 22

    variable_matrix_assign         shift and go to state 177

state 164

    (30) do_loops -> DO paso1DO LOOP d WHILE . expression_logic END_DO paso2DO
    (73) expression_logic -> . expression_logic OR g
    (74) expression_logic -> . g
    (75) g -> . g AND ge
    (76) g -> . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    expression_logic               shift and go to state 178
    g                              shift and go to state 54
    ge                             shift and go to state 55

state 165

    (31) do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit . paso3DoExit
    (93) paso3DoExit -> . empty
    (95) empty -> .

    EXIT            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    PRINT           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    LOOP            reduce using rule 95 (empty -> .)
    CALL            reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    END_LOOP        reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)
    END_DO          reduce using rule 95 (empty -> .)
    END_FOR         reduce using rule 95 (empty -> .)

    paso3DoExit                    shift and go to state 179
    empty                          shift and go to state 180

state 166

    (92) paso2DoExit -> empty .

    EXIT            reduce using rule 92 (paso2DoExit -> empty .)
    ID              reduce using rule 92 (paso2DoExit -> empty .)
    PRINT           reduce using rule 92 (paso2DoExit -> empty .)
    IF              reduce using rule 92 (paso2DoExit -> empty .)
    FOR             reduce using rule 92 (paso2DoExit -> empty .)
    DO              reduce using rule 92 (paso2DoExit -> empty .)
    LOOP            reduce using rule 92 (paso2DoExit -> empty .)
    CALL            reduce using rule 92 (paso2DoExit -> empty .)
    READ            reduce using rule 92 (paso2DoExit -> empty .)
    END             reduce using rule 92 (paso2DoExit -> empty .)
    END_LOOP        reduce using rule 92 (paso2DoExit -> empty .)
    WHILE           reduce using rule 92 (paso2DoExit -> empty .)
    ELSIF           reduce using rule 92 (paso2DoExit -> empty .)
    ELSE            reduce using rule 92 (paso2DoExit -> empty .)
    END_IF          reduce using rule 92 (paso2DoExit -> empty .)
    END_DO          reduce using rule 92 (paso2DoExit -> empty .)
    END_FOR         reduce using rule 92 (paso2DoExit -> empty .)


state 167

    (9) var_dimensiones -> LARR constante_entero COMMA constante_entero . RARR

    RARR            shift and go to state 181


state 168

    (70) te -> ID LPAREN expression_arith RPAREN .

    MULTIPLY        reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    DIVIDE          reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    PLUS            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    MINUS           reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    EXIT            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    ID              reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    PRINT           reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    IF              reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    FOR             reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    DO              reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    LOOP            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    CALL            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    READ            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    END             reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    END_LOOP        reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    WHILE           reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    ELSIF           reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    ELSE            reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    END_IF          reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    END_DO          reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    END_FOR         reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    RPAREN          reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)
    COMMA           reduce using rule 70 (te -> ID LPAREN expression_arith RPAREN .)


state 169

    (71) te -> ID LPAREN expression_arith COMMA . expression_arith RPAREN
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 182
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 170

    (59) variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ID              reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    PRINT           reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    IF              reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    FOR             reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    DO              reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    LOOP            reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    CALL            reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    READ            reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END             reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_LOOP        reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    WHILE           reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ELSIF           reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    ELSE            reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_IF          reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_DO          reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    END_FOR         reduce using rule 59 (variable_matrix_assign -> ID LPAREN expression_arith RPAREN ASSIGN expression_arith .)
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 171

    (60) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN . ASSIGN expression_arith

    ASSIGN          shift and go to state 183


state 172

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 . paso2IF ELSE if_expression_local paso3IF END_IF
    (85) paso2IF -> . empty
    (95) empty -> .

    ELSE            reduce using rule 95 (empty -> .)

    paso2IF                        shift and go to state 184
    empty                          shift and go to state 185

state 173

    (42) if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF . END_IF

    END_IF          shift and go to state 186


state 174

    (45) if_expression_local2 -> ELSIF . expression_logic THEN if_expression_local if_expression_local2
    (73) expression_logic -> . expression_logic OR g
    (74) expression_logic -> . g
    (75) g -> . g AND ge
    (76) g -> . ge
    (77) ge -> . ID GT ID
    (78) ge -> . ID LT ID
    (79) ge -> . ID GE ID
    (80) ge -> . ID LE ID
    (81) ge -> . ID NE ID
    (82) ge -> . ID EQUAL ID
    (83) ge -> . LPAREN expression_logic RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 57

    expression_logic               shift and go to state 187
    g                              shift and go to state 54
    ge                             shift and go to state 55

state 175

    (46) if_expression_local2 -> empty .
    (86) paso3IF -> empty .

    ELSE            reduce using rule 46 (if_expression_local2 -> empty .)
    END_IF          reduce using rule 86 (paso3IF -> empty .)


state 176

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA . expression_arith paso3FOR DO d paso4FOR END_FOR
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 188
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 177

    (29) do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign . d END_DO
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    variable_matrix_assign         shift and go to state 25
    d                              shift and go to state 189
    b                              shift and go to state 24
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 178

    (30) do_loops -> DO paso1DO LOOP d WHILE expression_logic . END_DO paso2DO
    (73) expression_logic -> expression_logic . OR g

    END_DO          shift and go to state 190
    OR              shift and go to state 95


state 179

    (31) do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .

    EXIT            reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    ID              reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    PRINT           reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    IF              reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    FOR             reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    DO              reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    LOOP            reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    CALL            reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    READ            reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    END             reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    END_LOOP        reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    WHILE           reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    ELSIF           reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    ELSE            reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    END_IF          reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    END_DO          reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)
    END_FOR         reduce using rule 31 (do_loops -> LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit .)


state 180

    (93) paso3DoExit -> empty .

    EXIT            reduce using rule 93 (paso3DoExit -> empty .)
    ID              reduce using rule 93 (paso3DoExit -> empty .)
    PRINT           reduce using rule 93 (paso3DoExit -> empty .)
    IF              reduce using rule 93 (paso3DoExit -> empty .)
    FOR             reduce using rule 93 (paso3DoExit -> empty .)
    DO              reduce using rule 93 (paso3DoExit -> empty .)
    LOOP            reduce using rule 93 (paso3DoExit -> empty .)
    CALL            reduce using rule 93 (paso3DoExit -> empty .)
    READ            reduce using rule 93 (paso3DoExit -> empty .)
    END             reduce using rule 93 (paso3DoExit -> empty .)
    END_LOOP        reduce using rule 93 (paso3DoExit -> empty .)
    WHILE           reduce using rule 93 (paso3DoExit -> empty .)
    ELSIF           reduce using rule 93 (paso3DoExit -> empty .)
    ELSE            reduce using rule 93 (paso3DoExit -> empty .)
    END_IF          reduce using rule 93 (paso3DoExit -> empty .)
    END_DO          reduce using rule 93 (paso3DoExit -> empty .)
    END_FOR         reduce using rule 93 (paso3DoExit -> empty .)


state 181

    (9) var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .

    INT_TYPE        reduce using rule 9 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    FLOAT_TYPE      reduce using rule 9 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    SUBROUTINE      reduce using rule 9 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)
    BEGIN           reduce using rule 9 (var_dimensiones -> LARR constante_entero COMMA constante_entero RARR .)


state 182

    (71) te -> ID LPAREN expression_arith COMMA expression_arith . RPAREN
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    RPAREN          shift and go to state 191
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 183

    (60) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN . expression_arith
    (61) expression_arith -> . expression_arith PLUS c
    (62) expression_arith -> . expression_arith MINUS c
    (63) expression_arith -> . c
    (64) c -> . c MULTIPLY te
    (65) c -> . c DIVIDE te
    (66) c -> . te
    (67) te -> . ID
    (68) te -> . constante_entero
    (69) te -> . constante_flotante
    (70) te -> . ID LPAREN expression_arith RPAREN
    (71) te -> . ID LPAREN expression_arith COMMA expression_arith RPAREN
    (72) te -> . LPAREN expression_arith RPAREN
    (87) constante_entero -> . INT
    (88) constante_flotante -> . FLOAT

    ID              shift and go to state 76
    LPAREN          shift and go to state 82
    INT             shift and go to state 62
    FLOAT           shift and go to state 83

    expression_arith               shift and go to state 192
    c                              shift and go to state 78
    te                             shift and go to state 79
    constante_entero               shift and go to state 80
    constante_flotante             shift and go to state 81

state 184

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF . ELSE if_expression_local paso3IF END_IF

    ELSE            shift and go to state 193


state 185

    (85) paso2IF -> empty .

    ELSE            reduce using rule 85 (paso2IF -> empty .)


state 186

    (42) if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .

    EXIT            reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    ID              reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    PRINT           reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    IF              reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    FOR             reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    DO              reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    LOOP            reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    CALL            reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    READ            reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    END             reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    END_LOOP        reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    WHILE           reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    ELSIF           reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    ELSE            reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    END_IF          reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    END_DO          reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)
    END_FOR         reduce using rule 42 (if_expression -> IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF .)


state 187

    (45) if_expression_local2 -> ELSIF expression_logic . THEN if_expression_local if_expression_local2
    (73) expression_logic -> expression_logic . OR g

    THEN            shift and go to state 194
    OR              shift and go to state 95


state 188

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith . paso3FOR DO d paso4FOR END_FOR
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c
    (34) paso3FOR -> . empty
    (95) empty -> .

    PLUS            shift and go to state 116
    MINUS           shift and go to state 117
    DO              reduce using rule 95 (empty -> .)

    paso3FOR                       shift and go to state 195
    empty                          shift and go to state 196

state 189

    (29) do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d . END_DO

    END_DO          shift and go to state 197


state 190

    (30) do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO . paso2DO
    (90) paso2DO -> . empty
    (95) empty -> .

    EXIT            reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    PRINT           reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    DO              reduce using rule 95 (empty -> .)
    LOOP            reduce using rule 95 (empty -> .)
    CALL            reduce using rule 95 (empty -> .)
    READ            reduce using rule 95 (empty -> .)
    END             reduce using rule 95 (empty -> .)
    END_LOOP        reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    END_IF          reduce using rule 95 (empty -> .)
    END_DO          reduce using rule 95 (empty -> .)
    END_FOR         reduce using rule 95 (empty -> .)

    paso2DO                        shift and go to state 198
    empty                          shift and go to state 199

state 191

    (71) te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .

    MULTIPLY        reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    DIVIDE          reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    PLUS            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    MINUS           reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    EXIT            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ID              reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    PRINT           reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    IF              reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    FOR             reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    DO              reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    LOOP            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    CALL            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    READ            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END             reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_LOOP        reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    WHILE           reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ELSIF           reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    ELSE            reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_IF          reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_DO          reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    END_FOR         reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    RPAREN          reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)
    COMMA           reduce using rule 71 (te -> ID LPAREN expression_arith COMMA expression_arith RPAREN .)


state 192

    (60) variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .
    (61) expression_arith -> expression_arith . PLUS c
    (62) expression_arith -> expression_arith . MINUS c

    EXIT            reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ID              reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    PRINT           reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    IF              reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    FOR             reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    DO              reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    LOOP            reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    CALL            reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    READ            reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END             reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_LOOP        reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    WHILE           reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ELSIF           reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    ELSE            reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_IF          reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_DO          reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    END_FOR         reduce using rule 60 (variable_matrix_assign -> ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith .)
    PLUS            shift and go to state 116
    MINUS           shift and go to state 117


state 193

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE . if_expression_local paso3IF END_IF
    (43) if_expression_local -> . d
    (44) if_expression_local -> . empty
    (19) d -> . b
    (20) d -> . b d
    (95) empty -> .
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    END_IF          reduce using rule 95 (empty -> .)
    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    if_expression_local            shift and go to state 200
    d                              shift and go to state 159
    empty                          shift and go to state 160
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 194

    (45) if_expression_local2 -> ELSIF expression_logic THEN . if_expression_local if_expression_local2
    (43) if_expression_local -> . d
    (44) if_expression_local -> . empty
    (19) d -> . b
    (20) d -> . b d
    (95) empty -> .
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    ELSIF           reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)
    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    if_expression_local            shift and go to state 201
    d                              shift and go to state 159
    empty                          shift and go to state 160
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 195

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR . DO d paso4FOR END_FOR

    DO              shift and go to state 202


state 196

    (34) paso3FOR -> empty .

    DO              reduce using rule 34 (paso3FOR -> empty .)


state 197

    (29) do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .

    EXIT            reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ID              reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    PRINT           reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    IF              reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    FOR             reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    DO              reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    LOOP            reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    CALL            reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    READ            reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END             reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_LOOP        reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    WHILE           reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ELSIF           reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    ELSE            reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_IF          reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_DO          reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)
    END_FOR         reduce using rule 29 (do_loops -> DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO .)


state 198

    (30) do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .

    EXIT            reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    ID              reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    PRINT           reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    IF              reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    FOR             reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    DO              reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    LOOP            reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    CALL            reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    READ            reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    END             reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    END_LOOP        reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    WHILE           reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    ELSIF           reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    ELSE            reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    END_IF          reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    END_DO          reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)
    END_FOR         reduce using rule 30 (do_loops -> DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO .)


state 199

    (90) paso2DO -> empty .

    EXIT            reduce using rule 90 (paso2DO -> empty .)
    ID              reduce using rule 90 (paso2DO -> empty .)
    PRINT           reduce using rule 90 (paso2DO -> empty .)
    IF              reduce using rule 90 (paso2DO -> empty .)
    FOR             reduce using rule 90 (paso2DO -> empty .)
    DO              reduce using rule 90 (paso2DO -> empty .)
    LOOP            reduce using rule 90 (paso2DO -> empty .)
    CALL            reduce using rule 90 (paso2DO -> empty .)
    READ            reduce using rule 90 (paso2DO -> empty .)
    END             reduce using rule 90 (paso2DO -> empty .)
    END_LOOP        reduce using rule 90 (paso2DO -> empty .)
    WHILE           reduce using rule 90 (paso2DO -> empty .)
    ELSIF           reduce using rule 90 (paso2DO -> empty .)
    ELSE            reduce using rule 90 (paso2DO -> empty .)
    END_IF          reduce using rule 90 (paso2DO -> empty .)
    END_DO          reduce using rule 90 (paso2DO -> empty .)
    END_FOR         reduce using rule 90 (paso2DO -> empty .)


state 200

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local . paso3IF END_IF
    (86) paso3IF -> . empty
    (95) empty -> .

    END_IF          reduce using rule 95 (empty -> .)

    paso3IF                        shift and go to state 203
    empty                          shift and go to state 204

state 201

    (45) if_expression_local2 -> ELSIF expression_logic THEN if_expression_local . if_expression_local2
    (45) if_expression_local2 -> . ELSIF expression_logic THEN if_expression_local if_expression_local2
    (46) if_expression_local2 -> . empty
    (95) empty -> .

    ELSIF           shift and go to state 174
    ELSE            reduce using rule 95 (empty -> .)

    if_expression_local2           shift and go to state 205
    empty                          shift and go to state 206

state 202

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO . d paso4FOR END_FOR
    (19) d -> . b
    (20) d -> . b d
    (21) b -> . variable_matrix_assign
    (22) b -> . printing_variables
    (23) b -> . if_expression
    (24) b -> . do_loops
    (25) b -> . call_subroutine
    (26) b -> . reading_variables
    (27) b -> . EXIT paso4DoExit
    (58) variable_matrix_assign -> . ID ASSIGN expression_arith
    (59) variable_matrix_assign -> . ID LPAREN expression_arith RPAREN ASSIGN expression_arith
    (60) variable_matrix_assign -> . ID LPAREN expression_arith COMMA expression_arith RPAREN ASSIGN expression_arith
    (47) printing_variables -> . PRINT Output
    (41) if_expression -> . IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF
    (42) if_expression -> . IF expression_logic paso1IF THEN if_expression_local paso3IF END_IF
    (28) do_loops -> . FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR
    (29) do_loops -> . DO constante_entero COMMA constante_entero COMMA variable_matrix_assign d END_DO
    (30) do_loops -> . DO paso1DO LOOP d WHILE expression_logic END_DO paso2DO
    (31) do_loops -> . LOOP paso1DoExit d END_LOOP paso2DoExit paso3DoExit
    (40) call_subroutine -> . CALL ID
    (36) reading_variables -> . READ idrepInput

    EXIT            shift and go to state 31
    ID              shift and go to state 22
    PRINT           shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34
    DO              shift and go to state 35
    LOOP            shift and go to state 36
    CALL            shift and go to state 37
    READ            shift and go to state 38

    d                              shift and go to state 207
    b                              shift and go to state 24
    variable_matrix_assign         shift and go to state 25
    printing_variables             shift and go to state 26
    if_expression                  shift and go to state 27
    do_loops                       shift and go to state 28
    call_subroutine                shift and go to state 29
    reading_variables              shift and go to state 30

state 203

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF . END_IF

    END_IF          shift and go to state 208


state 204

    (86) paso3IF -> empty .

    END_IF          reduce using rule 86 (paso3IF -> empty .)


state 205

    (45) if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2 .

    ELSE            reduce using rule 45 (if_expression_local2 -> ELSIF expression_logic THEN if_expression_local if_expression_local2 .)


state 206

    (46) if_expression_local2 -> empty .

    ELSE            reduce using rule 46 (if_expression_local2 -> empty .)


state 207

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d . paso4FOR END_FOR
    (35) paso4FOR -> . empty
    (95) empty -> .

    END_FOR         reduce using rule 95 (empty -> .)

    paso4FOR                       shift and go to state 209
    empty                          shift and go to state 210

state 208

    (41) if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .

    EXIT            reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    ID              reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    PRINT           reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    IF              reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    FOR             reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    DO              reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    LOOP            reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    CALL            reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    READ            reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    END             reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    END_LOOP        reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    WHILE           reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    ELSIF           reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    ELSE            reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    END_IF          reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    END_DO          reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)
    END_FOR         reduce using rule 41 (if_expression -> IF expression_logic paso1IF THEN if_expression_local if_expression_local2 paso2IF ELSE if_expression_local paso3IF END_IF .)


state 209

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR . END_FOR

    END_FOR         shift and go to state 211


state 210

    (35) paso4FOR -> empty .

    END_FOR         reduce using rule 35 (paso4FOR -> empty .)


state 211

    (28) do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .

    EXIT            reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    ID              reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    PRINT           reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    IF              reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    FOR             reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    DO              reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    LOOP            reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    CALL            reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    READ            reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    END             reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    END_LOOP        reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    WHILE           reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    ELSIF           reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    ELSE            reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    END_IF          reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    END_DO          reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)
    END_FOR         reduce using rule 28 (do_loops -> FOR paso1FOR ASSIGN expression_arith paso2FOR COMMA expression_arith paso3FOR DO d paso4FOR END_FOR .)

